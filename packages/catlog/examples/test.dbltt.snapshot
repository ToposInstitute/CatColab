set_theory ThSchema
#/ result: set theory to ThSchema

type u := Unit
#/ declared: u

type u2 := u
#/ declared: u2

def t : u := 'tt
#/ declared: t

type WeightedGraph := [
  V : Entity,
  E : Entity,
  Weight : AttrType,
  src : (Id Entity)[E, V],
  tgt : (Id Entity)[E, V],
  weight : Attr[E, Weight]
]
#/ declared: WeightedGraph

generate WeightedGraph
#/ result: 
#/ object generators:
#/   V : Entity
#/   E : Entity
#/   Weight : AttrType
#/ morphism generators:
#/   src : E -> V (Id Entity)
#/   tgt : E -> V (Id Entity)
#/   weight : E -> Weight (Attr)


type EntityArr := [
  dom : Entity,
  cod : Entity,
  arr : (Id Entity)[dom, cod]
]
#/ declared: EntityArr

type Graph1 := [
  V : Entity,
  E : Entity,
  src : EntityArr & [ .dom := E, .cod := V ],
  tgt : EntityArr & [ .dom := E, .cod := V ],
]
#/ declared: Graph1

chk [G : Graph1] (G.src.arr : (Id Entity)[G.E, G.V])
#/ result: G.src.arr

chk [G : Graph1] (G.src : EntityArr)
#/ result: G.src

chk [G : Graph1] (G.src : EntityArr & [ .dom := G.E ] )
#/ result: G.src

#(should_fail)
chk [G : Graph1] (G.src : EntityArr & [ .dom := G.V ] )
#/ result: ?0
#/ expected errors:
#/ error[elab]: evaluated term [ dom := G.E, cod := G.V, arr := <opaque> ] is not an element of specialized type [ dom : Entity, cod : Entity, arr : (Id Entity)[ self.dom, self.cod ] ] &
#/   [ .dom : @sing G.V ]:
#/ Neutrals G.E and G.V are not equal.
#/ --> examples/test.dbltt:41:19
#/ 41| chk [G : Graph1] (G.src : EntityArr & [ .dom := G.V ] )
#/ 41|                   ^^^^^

norm [x : [a : Entity, b : @sing a]] x.b
#/ result: x.a

#(should_fail)
type Graph1 := [
  V : Entity,
  E : Entity,
  src : EntityArr & [ .dom := E, .dom := V ]
]
#/ declared: Graph1
#/ expected errors:
#/ error[elab]: Failed to specialize:
#/ ... because @sing self.V is not a subtype of @sing self.E:
#/ ... because Neutrals self.V and self.E are not equal.
#/ --> examples/test.dbltt:49:34
#/ 49|   src : EntityArr & [ .dom := E, .dom := V ]
#/ 49|                                  ^^^^^^^^^

type Graph := [
  V : Entity,
  E : Entity,
  src : (Id Entity)[E, V],
  tgt : (Id Entity)[E, V]
]
#/ declared: Graph

def reverse[G : Graph] : Graph := [
  V := G.V,
  E := G.E,
  src := G.tgt,
  tgt := G.src
]
#/ declared: reverse

#(should_fail)
def reverse1[G : Graph] : Graph := [
  V := G.E,
  E := G.E,
  src := G.tgt,
  tgt := G.src
]
#/ declared: reverse1
#/ expected errors:
#/ error[elab]: synthesized type (Id Entity)[ G.E, G.V ] does not match expected type (Id Entity)[ G.E, G.E ]:
#/ could not convert codomains: Neutrals G.V and G.E are not equal.
#/ --> examples/test.dbltt:70:10
#/ 70|   src := G.tgt,
#/ 70|          ^^^^^
#/ error[elab]: synthesized type (Id Entity)[ G.E, G.V ] does not match expected type (Id Entity)[ G.E, G.E ]:
#/ could not convert codomains: Neutrals G.V and G.E are not equal.
#/ --> examples/test.dbltt:71:10
#/ 71|   tgt := G.src
#/ 71|          ^^^^^

norm [G : Graph] (reverse[G]).E
#/ result: G.E

syn [G : Graph] (reverse[G]).src
#/ result: reverse[ G ].src : (Id Entity)[ G.E, G.V ]

type ReflexiveGraph := [
  V : Entity,
  E : Entity,
  src : (Id Entity)[E, V],
  tgt : (Id Entity)[E, V],
  refl : (Id Entity)[V, E]
]
#/ declared: ReflexiveGraph

def edge_id[G : ReflexiveGraph] : (Id Entity)[G.E, G.E] := @id G.E
#/ declared: edge_id

def edge_src[G : ReflexiveGraph] : (Id Entity)[G.E, G.E] := G.src * G.refl
#/ declared: edge_src

type Graph2 := [
  V : Entity,
  g1 : Graph & [ .V := V],
  g2 : Graph & [ .V := V]
]
#/ declared: Graph2

syn [g : Graph2] g.g1.V
#/ result: g.g1.V : @sing g.V

norm [g : Graph2] g.g1.V
#/ result: g.V

generate Graph2
#/ result: 
#/ object generators:
#/   V : Entity
#/   g1.E : Entity
#/   g2.E : Entity
#/ morphism generators:
#/   g1.src : g1.E -> V (Id Entity)
#/   g1.tgt : g1.E -> V (Id Entity)
#/   g2.src : g2.E -> V (Id Entity)
#/   g2.tgt : g2.E -> V (Id Entity)


type WeightedGraph2 := [
  V : Entity,
  g1 : WeightedGraph & [ .V := V ],
  g2 : WeightedGraph & [ .V := V ]
]
#/ declared: WeightedGraph2

generate WeightedGraph2
#/ result: 
#/ object generators:
#/   V : Entity
#/   g1.E : Entity
#/   g1.Weight : AttrType
#/   g2.E : Entity
#/   g2.Weight : AttrType
#/ morphism generators:
#/   g1.src : g1.E -> V (Id Entity)
#/   g1.tgt : g1.E -> V (Id Entity)
#/   g1.weight : g1.E -> g1.Weight (Attr)
#/   g2.src : g2.E -> V (Id Entity)
#/   g2.tgt : g2.E -> V (Id Entity)
#/   g2.weight : g2.E -> g2.Weight (Attr)


set_theory ThCategory
#/ result: set theory to ThCategory

#(should_fail)
type Set := [
  A : Entity,
]
#/ declared: Set
#/ expected errors:
#/ error[elab]: no such type Entity defined
#/ --> examples/test.dbltt:113:7
#/ 113|   A : Entity,
#/ 113|       ^^^^^^

type Set := [
  A : Object
]
#/ declared: Set

type DDS := [
  X : Object,
  Ï† : (Id Object)[X, X]
]
#/ declared: DDS

set_theory ThSignedCategory
#/ result: set theory to ThSignedCategory

type NegFeedback := [
  X : Object,
  Y : Object,
  f : (Id Object)[X, Y],
  g : Negative[Y, X]
]
#/ declared: NegFeedback

generate NegFeedback
#/ result: 
#/ object generators:
#/   X : Object
#/   Y : Object
#/ morphism generators:
#/   f : X -> Y (Id Object)
#/   g : Y -> X (Negative)


#(should_fail)
type NegFeedback1 := [
  X : Object,
  Y : Object,
  f : (Id Object)[@hole, Y],
  g : Negative[Y, f]
]
#/ declared: NegFeedback1
#/ expected errors:
#/ error[elab]: explicit hole
#/ --> examples/test.dbltt:140:19
#/ 140|   f : (Id Object)[@hole, Y],
#/ 140|                   ^^^^^
#/ error[elab]: synthesized type (Id Object)[ ?0, self.Y ] does not match expected type Object:
#/ tried to convert between types of different type constructors
#/ --> examples/test.dbltt:141:19
#/ 141|   g : Negative[Y, f]
#/ 141|                   ^

generate NegFeedback1
#/ result: 
#/ object generators:
#/   X : Object
#/   Y : Object
#/ morphism generators:


