//! Generate catlog models from DoubleTT types.

use all_the_same::all_the_same;
use derive_more::TryInto;

use super::{eval::*, prelude::*, text_elab, theory::*, toplevel::*, val::*};
use crate::dbl::{
    discrete, modal,
    model::{DblModel, DblModelPrinter, MutDblModel},
    theory::DblTheory,
};
use crate::one::path::{Path, PathEq};
use crate::zero::{Namespace, QualifiedName};

/// A model generated by DoubleTT.
///
/// Similarly to [`TheoryDef`], this enum boxes the different types of models
/// that can be generated by DoubleTT.
pub enum Model {
    /// A model of a discrete double theory.
    Discrete(Box<discrete::DiscreteDblModel>),
    /// A model of a modal double theory.
    Modal(Box<modal::ModalDblModel>),
}

/// An object in a model generated by DoubleTT.
#[derive(Debug, TryInto)]
enum Ob {
    Discrete(QualifiedName),
    Modal(modal::ModalOb),
}

/// A morphism in a model generated by DoubleTT.
#[derive(Debug, TryInto)]
enum Mor {
    Discrete(Path<QualifiedName, QualifiedName>),
    Modal(modal::ModalMor),
}

impl Model {
    /// Constructs an empty model of a theory.
    pub fn new(theory: &TheoryDef) -> Self {
        match theory {
            TheoryDef::Discrete(theory) => {
                Model::Discrete(Box::new(discrete::DiscreteDblModel::new(theory.clone())))
            }
            TheoryDef::Modal(theory) => {
                Model::Modal(Box::new(modal::ModalDblModel::new(theory.clone())))
            }
        }
    }

    /// Parses and generates a model from plain text.
    pub fn from_text(th: &TheoryDef, s: &str) -> Option<Self> {
        let theory = Theory::new("_".into(), th.clone());
        let reporter = Reporter::new();
        let toplevel: Toplevel = Default::default();
        text_elab::TT_PARSE_CONFIG.with_parsed(s, reporter.clone(), |fntn| {
            let mut elaborator = text_elab::Elaborator::new(theory, reporter, &toplevel);
            let (_, ty_v) = elaborator.ty(fntn);
            let (model, _) = Self::from_ty(&toplevel, th, &ty_v);
            Some(model)
        })
    }

    /// Generates a model from a type.
    ///
    /// Precondition: `ty` must be valid in the empty context.
    pub fn from_ty(toplevel: &Toplevel, th: &TheoryDef, ty: &TyV) -> (Self, Namespace) {
        let mut generator = ModelGenerator::new(toplevel, th);
        let namespace = generator.generate(ty);
        (generator.model, namespace)
    }

    /// Tries to extract a model of a discrete theory.
    pub fn as_discrete(self) -> Option<discrete::DiscreteDblModel> {
        match self {
            Model::Discrete(model) => Some(*model),
            _ => None,
        }
    }

    /// Tries to extract a model of a modal theory.
    pub fn as_modal(self) -> Option<modal::ModalDblModel> {
        match self {
            Model::Modal(model) => Some(*model),
            _ => None,
        }
    }

    /// Adds an object generator to the model.
    fn add_ob(&mut self, name: QualifiedName, ob_type: ObType) {
        all_the_same!(match self {
            Model::[Discrete, Modal](model) => {
                model.add_ob(name, ob_type.try_into().unwrap())
            }
        });
    }

    /// Adds a morphism generator to the model.
    fn add_mor(&mut self, name: QualifiedName, dom: Ob, cod: Ob, mor_type: MorType) {
        all_the_same!(match self {
            Model::[Discrete, Modal](model) => {
                model.add_mor(
                    name,
                    dom.try_into().unwrap(),
                    cod.try_into().unwrap(),
                    mor_type.try_into().unwrap()
                );
            }
        });
    }

    /// Adds an equation between two morphisms to the model.
    fn add_equation(&mut self, lhs: Mor, rhs: Mor) {
        if let (Model::Discrete(model), Mor::Discrete(lhs), Mor::Discrete(rhs)) = (self, lhs, rhs) {
            model.add_equation(PathEq::new(lhs, rhs));
        }
        // Modal models currently do not support equations, so we ignore them.
        {}
    }

    /// Pretty prints a summary of the model.
    pub fn summary(&self, printer: &DblModelPrinter) -> String {
        all_the_same!(match self {
            Model::[Discrete, Modal](model) => printer.summary(model.as_ref())
        })
    }

    /// Pretty prints the model in the given namespace.
    pub fn to_doc<'a>(&self, printer: &DblModelPrinter, ns: &Namespace) -> D<'a> {
        all_the_same!(match self {
            Model::[Discrete, Modal](model) => printer.namespaced_doc(model.as_ref(), ns, ns)
        })
    }
}

struct ModelGenerator<'a> {
    eval: Evaluator<'a>,
    theory: TheoryDef,
    model: Model,
}

impl<'a> ModelGenerator<'a> {
    fn new(toplevel: &'a Toplevel, theory: &TheoryDef) -> Self {
        let eval = Evaluator::empty(toplevel);
        let theory = theory.clone();
        let model = Model::new(&theory);
        Self { eval, theory, model }
    }

    fn generate(&mut self, ty: &TyV) -> Namespace {
        let tm_n;
        (tm_n, self.eval) = self.eval.bind_self(ty.clone());
        let tm_v = self.eval.eta_neu(&tm_n, ty);
        self.extract(vec![], &tm_v, ty).unwrap_or_else(Namespace::new_for_uuid)
    }

    /// Constructs a generating object.
    fn ob_generator(&self, name: QualifiedName) -> Ob {
        match &self.model {
            Model::Discrete(_) => Ob::Discrete(name),
            Model::Modal(_) => Ob::Modal(modal::ModalOb::Generator(name)),
        }
    }

    /// Constructs an application of an object operation, if possible.
    fn ob_app(&self, name: QualifiedName, tm_v: &TmV) -> Option<Ob> {
        match &self.model {
            Model::Discrete(_) => None,
            Model::Modal(model) => {
                let theory = model.theory();
                let op = modal::ModalObOp::generator(name.clone());
                let ob = self.make_ob(tm_v, &theory.ob_op_dom(&op).into())?;
                let ob = ob.try_into().unwrap();
                Some(Ob::Modal(modal::ModalOb::App(Box::new(ob), name)))
            }
        }
    }

    /// Constructs a list of objects, if allowed.
    fn ob_list(&self, elems: Vec<Ob>, ob_type: &ObType) -> Option<Ob> {
        match &self.model {
            Model::Discrete(_) => None,
            Model::Modal(_) => {
                let ob_type: &modal::ModalObType = ob_type.try_into().unwrap();
                let Some(modal::Modality::List(list_type)) = ob_type.modalities.last() else {
                    return None;
                };
                Some(Ob::Modal(modal::ModalOb::List(
                    *list_type,
                    elems.into_iter().map(|ob| ob.try_into().unwrap()).collect(),
                )))
            }
        }
    }

    /// Attempts to make an object from a term.
    fn make_ob(&self, val: &TmV, ob_type: &ObType) -> Option<Ob> {
        match &**val {
            TmV_::Neu(n, _) => {
                let mut segments = Vec::new();
                let mut n = n.clone();
                while let TmN_::Proj(n1, f, _) = &*n.clone() {
                    n = n1.clone();
                    segments.push(*f);
                }
                segments.reverse();
                Some(self.ob_generator(segments.into()))
            }
            TmV_::App(name, tm_v) => self.ob_app([*name].into(), tm_v),
            TmV_::List(elems) => {
                let el_type = ob_type.clone().list_arg().unwrap();
                let elems: Option<Vec<_>> =
                    elems.iter().map(|tm| self.make_ob(tm, &el_type)).collect();
                self.ob_list(elems?, ob_type)
            }
            _ => None,
        }
    }

    /// Attempts to make a morphism from a term of the given morphism type.
    fn make_mor(&self, val: &TmV, mor_type: &MorType) -> Option<Mor> {
        match &**val {
            TmV_::Neu(n, _) => {
                let mut segments = Vec::new();
                let mut n = n.clone();
                while let TmN_::Proj(n1, f, _) = &*n.clone() {
                    n = n1.clone();
                    segments.push(*f);
                }
                segments.reverse();
                let name: QualifiedName = segments.into();
                match &self.model {
                    Model::Discrete(_) => Some(Mor::Discrete(Path::single(name))),
                    Model::Modal(_) => Some(Mor::Modal(modal::ModalMor::Generator(name))),
                }
            }
            TmV_::Id(x) => {
                let ob = self.make_ob(x, &self.theory.src_type(mor_type))?;
                match ob {
                    Ob::Discrete(name) => Some(Mor::Discrete(Path::Id(name))),
                    Ob::Modal(ob) => {
                        Some(Mor::Modal(modal::ModalMor::Composite(Box::new(Path::Id(ob)))))
                    }
                }
            }
            TmV_::Compose(f, g) => {
                let mf = self.make_mor(f, mor_type)?;
                let mg = self.make_mor(g, mor_type)?;
                match (mf, mg) {
                    // Concatenation is valid because the type checker has
                    // already verified that the codomain of f equals the
                    // domain of g.
                    (Mor::Discrete(pf), Mor::Discrete(pg)) => {
                        Some(Mor::Discrete(concat_paths(pf, pg)))
                    }
                    (Mor::Modal(mf), Mor::Modal(mg)) => {
                        Some(Mor::Modal(modal::ModalMor::Composite(Box::new(concat_paths(
                            Path::single(mf),
                            Path::single(mg),
                        )))))
                    }
                    _ => None,
                }
            }
            _ => None,
        }
    }

    fn extract(&mut self, prefix: Vec<NameSegment>, val: &TmV, ty: &TyV) -> Option<Namespace> {
        match &**ty {
            TyV_::Object(ot) => {
                self.model.add_ob(prefix.into(), ot.clone());
                None
            }
            TyV_::Morphism(mt, dom, cod) => {
                let dom = self.make_ob(dom, &self.theory.src_type(mt))?;
                let cod = self.make_ob(cod, &self.theory.tgt_type(mt))?;
                self.model.add_mor(prefix.into(), dom, cod, mt.clone());
                None
            }
            TyV_::Record(r) => {
                let mut namespace = Namespace::new_for_uuid();
                for (name, (label, _)) in r.fields.iter() {
                    let mut prefix = prefix.clone();
                    prefix.push(*name);
                    if let NameSegment::Uuid(uuid) = name {
                        namespace.set_label(*uuid, *label);
                    }
                    let field_tm_v = self.eval.proj(val, *name, *label);
                    let field_ty_v = self.eval.field_ty(ty, val, *name);
                    if let Some(inner) = self.extract(prefix, &field_tm_v, &field_ty_v) {
                        namespace.add_inner(*name, inner);
                    };
                }
                Some(namespace)
            }
            TyV_::Sing(_, _) => None,
            TyV_::Id(mor_ty, lhs, rhs) => {
                let TyV_::Morphism(mt, _, _) = &**mor_ty else {
                    return None;
                };
                if let (Some(lhs), Some(rhs)) = (self.make_mor(lhs, mt), self.make_mor(rhs, mt)) {
                    self.model.add_equation(lhs, rhs);
                }
                None
            }
            TyV_::Unit => None,
            TyV_::Meta(_) => None,
        }
    }
}

/// Concatenates two paths without validation.
///
/// This is safe when the type checker has already verified that the paths are
/// composable (the target of `p` equals the source of `q`).
fn concat_paths<V, E>(p: Path<V, E>, q: Path<V, E>) -> Path<V, E> {
    match (p, q) {
        (path, Path::Id(_)) => path,
        (Path::Id(_), path) => path,
        (Path::Seq(mut edges), Path::Seq(mut other_edges)) => {
            edges.push(other_edges.head);
            edges.append(&mut other_edges.tail);
            Path::Seq(edges)
        }
    }
}
