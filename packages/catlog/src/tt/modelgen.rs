//! Generate catlog models from DoubleTT types.

use all_the_same::all_the_same;

use crate::dbl::{
    discrete, modal,
    model::{DblModelPrinter, MutDblModel},
};
use crate::tt::{eval::*, prelude::*, theory::*, toplevel::*, val::*};
use crate::zero::{Namespace, QualifiedName};

/// A model generated by DoubleTT.
///
/// Similarly to [`TheoryDef`], this enum boxes the different types of models
/// that can be generated by DoubleTT.
pub enum Model {
    /// A model of a discrete double theory.
    Discrete(Box<discrete::DiscreteDblModel>),
    /// A model of a modal double theory.
    Modal(Box<modal::ModalDblModel>),
}

impl Model {
    /// Constructs an empty model of a theory.
    pub fn new(theory: &TheoryDef) -> Self {
        match theory {
            TheoryDef::Discrete(theory) => {
                Model::Discrete(Box::new(discrete::DiscreteDblModel::new(theory.clone())))
            }
            TheoryDef::Modal(theory) => {
                Model::Modal(Box::new(modal::ModalDblModel::new(theory.clone())))
            }
        }
    }

    /// Adds an object generator to the model.
    fn add_ob(&mut self, name: QualifiedName, ob_type: ObType) {
        all_the_same!(match self {
            Model::[Discrete, Modal](model) => {
                model.add_ob(name, ob_type.try_into().unwrap())
            }
        });
    }

    /// Adds a morphism generator to the model.
    fn add_mor(
        &mut self,
        name: QualifiedName,
        dom: &TmV,
        cod: &TmV,
        mor_type: MorType,
    ) -> Option<()> {
        // FIXME: Need a more flexible pattern to extract objects from terms.
        match self {
            Model::Discrete(model) => {
                model.add_mor(name, name_of(dom)?, name_of(cod)?, mor_type.try_into().unwrap());
            }
            Model::Modal(model) => {
                model.add_mor(
                    name,
                    modal::ModalOb::Generator(name_of(dom)?),
                    modal::ModalOb::Generator(name_of(cod)?),
                    mor_type.try_into().unwrap(),
                );
            }
        }
        Some(())
    }

    /// Pretty prints a summary of the model.
    pub fn summary(&self, printer: &DblModelPrinter) -> String {
        all_the_same!(match self {
            Model::[Discrete, Modal](model) => printer.summary(model.as_ref())
        })
    }

    /// Pretty prints the model in the given namespace.
    pub fn to_doc<'a>(&self, printer: &DblModelPrinter, ns: &Namespace) -> D<'a> {
        all_the_same!(match self {
            Model::[Discrete, Modal](model) => printer.namespaced_doc(model.as_ref(), ns, ns)
        })
    }
}

/// Generate a discrete double model from a type.
///
/// Precondition: `ty` must be valid in the empty context.
pub fn generate(toplevel: &Toplevel, theory: &Theory, ty: &TyV) -> (Model, Namespace) {
    let mut generator = ModelGenerator::new(toplevel, theory);
    let namespace = generator.generate(ty);
    (generator.output, namespace)
}

struct ModelGenerator<'a> {
    eval: Evaluator<'a>,
    output: Model,
}

impl<'a> ModelGenerator<'a> {
    fn new(toplevel: &'a Toplevel, theory: &Theory) -> Self {
        let eval = Evaluator::new(toplevel, Env::Nil, 0);
        let output = Model::new(&theory.definition);
        Self { eval, output }
    }

    fn generate(&mut self, ty: &TyV) -> Namespace {
        let elt;
        (elt, self.eval) = self.eval.bind_self(ty.clone());
        let elt = self.eval.eta_neu(&elt, ty);
        self.extract(vec![], &elt, ty).unwrap_or_else(Namespace::new_for_uuid)
    }

    fn extract(&mut self, prefix: Vec<NameSegment>, val: &TmV, ty: &TyV) -> Option<Namespace> {
        match &**ty {
            TyV_::Object(ot) => {
                self.output.add_ob(prefix.into(), ot.clone());
                None
            }
            TyV_::Morphism(mt, dom, cod) => {
                self.output.add_mor(prefix.into(), dom, cod, mt.clone())?;
                None
            }
            TyV_::Record(r) => {
                let mut namespace = Namespace::new_for_uuid();
                for (name, (label, _)) in r.fields.iter() {
                    let mut prefix = prefix.clone();
                    prefix.push(*name);
                    match name {
                        NameSegment::Uuid(uuid) => {
                            namespace.set_label(*uuid, *label);
                        }
                        NameSegment::Text(_) => {}
                    }
                    if let Some(inner) = self.extract(
                        prefix,
                        &self.eval.proj(val, *name, *label),
                        &self.eval.field_ty(ty, val, *name),
                    ) {
                        namespace.add_inner(*name, inner);
                    };
                }
                Some(namespace)
            }
            TyV_::Sing(_, _) => None,
            TyV_::Unit => None,
            TyV_::Meta(_) => None,
        }
    }
}

// val must be an eta-expanded element of an object type
fn name_of(val: &TmV) -> Option<QualifiedName> {
    let mut out = Vec::new();
    let TmV::Neu(mut n, _) = val.clone() else {
        return None;
    };
    while let TmN_::Proj(n1, f, _) = &*n.clone() {
        n = n1.clone();
        out.push(*f);
    }
    out.reverse();
    Some(out.into())
}
