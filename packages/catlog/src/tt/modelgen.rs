//! Generate catlog models from DoubleTT types.

use crate::dbl::model::{DblModel, DiscreteDblModel, FgDblModel, MutDblModel};
use crate::one::FgCategory;
use crate::tt::{eval::*, prelude::*, theory::*, toplevel::*, val::*};
use crate::zero::{Namespace, QualifiedName};

/// A model generated by DoubleTT.
pub enum Model {
    /// A model of a discrete double theory.
    Discrete(DiscreteDblModel),
    // A model of a modal double theory.
    // Modal(ModalDblModel),
}

impl Model {
    /// Constructs an empty model of a theory.
    pub fn new(theory: &TheoryDef) -> Self {
        match theory {
            TheoryDef::Discrete(theory) => Model::Discrete(DiscreteDblModel::new(theory.clone())),
        }
    }

    /// Adds an object generator to the model.
    fn add_ob(&mut self, name: QualifiedName, ob_type: ObType) {
        match (self, ob_type) {
            (Model::Discrete(model), ObType::Discrete(ob_type)) => {
                model.add_ob(name, ob_type);
            }
        }
    }

    /// Adds a morphism generator to the model.
    fn add_mor(
        &mut self,
        name: QualifiedName,
        dom: &TmV,
        cod: &TmV,
        mor_type: MorType,
    ) -> Option<()> {
        match (self, mor_type) {
            (Model::Discrete(model), MorType::Discrete(mor_type)) => {
                model.add_mor(name, name_of(dom)?, name_of(cod)?, mor_type);
            }
        }
        Some(())
    }
}

/// Generate a discrete double model from a type.
///
/// Precondition: `ty` must be valid in the empty context.
pub fn generate(toplevel: &Toplevel, theory: &Theory, ty: &TyV) -> (Model, Namespace) {
    let eval = Evaluator::new(toplevel, Env::Nil, 0);
    let (elt, eval) = eval.bind_self(ty.clone());
    let elt = eval.eta_neu(&elt, ty);
    let mut out = Model::new(&theory.definition);
    let namespace =
        extract_to(&eval, &mut out, vec![], &elt, ty).unwrap_or_else(Namespace::new_for_uuid);
    (out, namespace)
}

// val must be an eta-expanded element of an object type
fn name_of(val: &TmV) -> Option<QualifiedName> {
    let mut out = Vec::new();
    let TmV::Neu(mut n, _) = val.clone() else {
        return None;
    };
    while let TmN_::Proj(n1, f, _) = &*n.clone() {
        n = n1.clone();
        out.push(*f);
    }
    out.reverse();
    Some(out.into())
}

fn extract_to(
    eval: &Evaluator,
    out: &mut Model,
    prefix: Vec<NameSegment>,
    val: &TmV,
    ty: &TyV,
) -> Option<Namespace> {
    match &**ty {
        TyV_::Object(ot) => {
            out.add_ob(prefix.clone().into(), ot.clone());
            None
        }
        TyV_::Morphism(mt, dom, cod) => {
            out.add_mor(prefix.clone().into(), dom, cod, mt.clone())?;
            None
        }
        TyV_::Record(r) => {
            let mut namespace = Namespace::new_for_uuid();
            for (name, (label, _)) in r.fields.iter() {
                let mut prefix = prefix.clone();
                prefix.push(*name);
                match name {
                    NameSegment::Uuid(uuid) => {
                        namespace.set_label(*uuid, *label);
                    }
                    NameSegment::Text(_) => {}
                }
                if let Some(inner) = extract_to(
                    eval,
                    out,
                    prefix,
                    &eval.proj(val, *name, *label),
                    &eval.field_ty(ty, val, *name),
                ) {
                    namespace.add_inner(*name, inner);
                };
            }
            Some(namespace)
        }
        TyV_::Sing(_, _) => None,
        TyV_::Unit => None,
        TyV_::Meta(_) => None,
    }
}

/// Pretty print model output as a document.
pub fn model_output<'a>(model: &Model, name_translation: &Namespace) -> D<'a> {
    #[allow(irrefutable_let_patterns)]
    let Model::Discrete(model) = model else {
        todo!("Model output only supported for discrete theories");
    };

    let sep = |sep: &'a str| s() + t(sep) + s();

    let ob_entries = model.ob_generators().map(|obgen| {
        (name_translation.label(&obgen).unwrap().to_doc()
            + sep(":")
            + model.ob_type(&obgen).to_doc())
        .group()
    });
    let ob_section = intersperse_hardlines(ob_entries);

    let mor_entries = model.mor_generators().map(|morgen| {
        (name_translation.label(&morgen).unwrap().to_doc()
            + sep(":")
            + name_translation.label(&model.mor_generator_dom(&morgen)).unwrap().to_doc()
            + sep("->")
            + name_translation.label(&model.mor_generator_cod(&morgen)).unwrap().to_doc()
            + sep(":")
            + MorType::Discrete(model.mor_generator_type(&morgen)).to_doc())
        .group()
    });
    let mor_section = intersperse_hardlines(mor_entries);

    ob_section + hardline() + mor_section
}
