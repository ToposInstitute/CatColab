/*!
Virtual Equipments

This module defines the VEquipment trait and associated implementations,
types traits.
*/

use super::category::*;
use crate::one::path::Path;

/**
nw         ne
|          |
w          e
|          |
sw----s----se
**/
pub struct Niche<V, E, ProE> {
    nw: V,
    ne: V,
    sw: V,
    se: V,
    w: E,
    e: E,
    s: ProE,
}

// todo: maybe implementation of VDblGraph for Niche?

/// A trait for virtual equipments that extends the VDblCategory trait
pub trait VEquipment: VDblCategory {
    /// Restriction
    fn restrict(&self, n: Niche<Self::Ob, Self::Arr, Self::Pro>) -> Self::Cell;
}

impl VEquipment for WalkingCategory {
    fn restrict(&self, _n: Niche<Self::Ob, Self::Arr, Self::Pro>) -> Self::Cell {
        1
    }
}

impl VEquipment for WalkingBimodule::Main {
    fn restrict(&self, n: Niche<Self::Ob, Self::Arr, Self::Pro>) -> Self::Cell {
        Path::single(n.s)
    }
}

// pub mod WalkingAdjunction {
//     /*! The walking bimodule as a VDC.

//     The **walking bimodule**, also known as the **walking profunctor**, is the
//     unital virtual double category freely generated by a pair of objects, here
//     called [`Left`](Ob::Left) and [`Right`](Ob::Right), and a single proarrow
//     between them, here called [`Middle`](Pro::Middle). In fact, this VDC has all
//     composites.
//     */
//     use super::super::graph::ProedgeGraph;
//     use super::*;

//     /// Struct representing the walking bimodule.
//     pub struct Main();

//     /// Type of objects in the walking bimodule.
//     #[derive(Clone, Copy, Debug, PartialEq, Eq)]
//     pub enum Ob {
//         /// Object representing the source of the bimodule.
//         Left,
//         /// Object representing the target of the bimodule.
//         Right,
//     }

//     /// Type of proarrows in the walking bimodule.
//     #[derive(Clone, Copy, Debug, PartialEq, Eq)]
//     pub enum Pro {
//         /// Unit proarrow on the object [`Left`](Ob::Left).
//         Left,
//         /// Generating proarrow from [`Left`](Ob::Left) to [`Right`](Ob::Right).
//         Middle,
//         /// Unit proarrow on the object [`Right`](Ob::Right).
//         Right,
//     }

//     impl Pro {
//         fn src(self) -> Ob {
//             match self {
//                 Pro::Left => Ob::Left,
//                 Pro::Middle => Ob::Left,
//                 Pro::Right => Ob::Right,
//             }
//         }

//         fn tgt(self) -> Ob {
//             match self {
//                 Pro::Left => Ob::Left,
//                 Pro::Middle => Ob::Right,
//                 Pro::Right => Ob::Right,
//             }
//         }
//     }

//     impl VDblCategory for Main {
//         type Ob = Ob;
//         type Arr = Ob;
//         type Pro = Pro;
//         type Cell = Path<Ob, Pro>;

//         fn has_ob(&self, _: &Self::Ob) -> bool {
//             true
//         }
//         fn has_arrow(&self, _: &Self::Arr) -> bool {
//             true
//         }
//         fn has_proarrow(&self, _: &Self::Pro) -> bool {
//             true
//         }
//         fn has_cell(&self, path: &Path<Ob, Pro>) -> bool {
//             path.contained_in(ProedgeGraph::ref_cast(UnderlyingDblGraph::ref_cast(self)))
//         }

//         fn dom(&self, f: &Self::Arr) -> Self::Ob {
//             *f
//         }
//         fn cod(&self, f: &Self::Arr) -> Self::Ob {
//             *f
//         }
//         fn src(&self, m: &Self::Pro) -> Self::Ob {
//             m.src()
//         }
//         fn tgt(&self, m: &Self::Pro) -> Self::Ob {
//             m.tgt()
//         }

//         fn cell_dom(&self, path: &Path<Ob, Pro>) -> Path<Self::Ob, Self::Pro> {
//             path.clone()
//         }
//         fn cell_cod(&self, path: &Path<Ob, Pro>) -> Self::Pro {
//             assert!(self.has_cell(path));
//             match path {
//                 Path::Id(Ob::Left) => Pro::Left,
//                 Path::Id(Ob::Right) => Pro::Right,
//                 Path::Seq(pros) => {
//                     *pros.iter().find(|m| **m == Pro::Middle).unwrap_or_else(|| pros.first())
//                 }
//             }
//         }
//         fn cell_src(&self, path: &Path<Ob, Pro>) -> Self::Arr {
//             path.src(ProedgeGraph::ref_cast(UnderlyingDblGraph::ref_cast(self)))
//         }
//         fn cell_tgt(&self, path: &Path<Ob, Pro>) -> Self::Arr {
//             path.tgt(ProedgeGraph::ref_cast(UnderlyingDblGraph::ref_cast(self)))
//         }

//         fn compose(&self, path: Path<Self::Ob, Self::Arr>) -> Self::Arr {
//             match path {
//                 Path::Id(x) => x,
//                 Path::Seq(arrows) => *arrows.first(),
//             }
//         }
//         fn compose_cells(&self, tree: DblTree<Self::Arr, Self::Pro, Self::Cell>) -> Self::Cell {
//             let path = tree.dom(UnderlyingDblGraph::ref_cast(self));
//             assert!(self.has_cell(&path));
//             path
//         }
//         fn composite_ext(&self, path: Path<Self::Ob, Self::Pro>) -> Option<Self::Cell> {
//             Some(path)
//         }
//     }
// }

#[cfg(test)]

mod tests {
    use super::*;

    #[test]
    fn walking_cat() {
        let v_eq = WalkingCategory();
        let niche = Niche {
            nw: (),
            ne: (),
            sw: (),
            se: (),
            w: (),
            e: (),
            s: (),
        };
        assert_eq!(v_eq.restrict(niche), 1)
    }

    #[test]
    fn walking_bimod() {
        let w_bm = WalkingBimodule::Main();
        let niche = Niche {
            nw: WalkingBimodule::Ob::Left,
            ne: WalkingBimodule::Ob::Right,
            sw: WalkingBimodule::Ob::Left,
            se: WalkingBimodule::Ob::Right,
            w: WalkingBimodule::Ob::Left,
            e: WalkingBimodule::Ob::Right,
            s: WalkingBimodule::Pro::Middle,
        };
        assert_eq!(w_bm.restrict(niche), Path::single(WalkingBimodule::Pro::Middle))
    }
}
