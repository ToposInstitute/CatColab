/*! Finitely presented categories.

A *finitely presented category*, or *f.p. category* for short, is a [finite
graph](super::graph::FinGraph) together with a finite set of [path
equations](super::path::PathEq). This data defines a category whose objects are
the vertices of the graph and morphisms are paths in the graphs, regarded as
equivalent under the congruence relation generated by the path equations. For a
detailed description of this congruence relation, see ([Spivak
2014](crate::refs::CTForTheSciences), Definition 4.5.2.3).

In general, this congruence relation---the word problem for finitely presented
categories---cannot be decided, though in practice it often can be. The data
structure in this module uses [e-graphs](https://en.wikipedia.org/wiki/E-graph)
to check for equivalence of paths under the congruence.
 */

use std::cell::RefCell;
use std::fmt::Debug;
use std::{collections::HashMap, hash::Hash};

use derivative::Derivative;
use egglog::{EGraph, ast::*, span};
use nonempty::NonEmpty;
use ref_cast::RefCast;
use thiserror::Error;
use ustr::Ustr;

use super::{category::*, graph::*, path::*};
use crate::egglog_util::{CommandRewrite, CommandRule, Program};
use crate::validate::{self, Validate};

/** A finitely presented category backed by an e-graph.

A data structure for a f.p. category in which the congruence relation generated
by the path equations is maintained by an e-graph. The question of whether paths
in the presented category are equivalent is referred to the e-graph.

# Interior mutability

Checking equivalence of paths requires mutating the underlying e-graph. However,
we do not want to regard this check as mutating, for the theoretical reason that
the check does not change the category presented and the practical reason that
it would cause mutable references to be aggressively propagated throughout the
codebase. Thus, we use the [interior
mutability](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html)
pattern to encapsulate the mutability of the e-graph and perform borrow checking
at runtime. The current implementation allows only *single-threaded* usage.
 */
#[derive(Clone, Derivative)]
#[derivative(Debug(bound = "V: Debug, E: Debug"))]
#[derivative(Default(bound = "", new = "true"))]
#[derivative(PartialEq(bound = "V: Eq + Hash, E: Eq + Hash"))]
#[derivative(Eq(bound = "V: Eq + Hash, E: Eq + Hash"))]
pub struct FpCategory<V, E> {
    generators: HashGraph<V, E>,
    equations: Vec<PathEq<V, E>>,
    #[derivative(Debug = "ignore", PartialEq = "ignore")]
    builder: RefCell<CategoryProgramBuilder<V, E>>,
    #[derivative(Debug = "ignore", PartialEq = "ignore")]
    egraph: RefCell<EGraph>,
}

/// A finitely presented category with generators of type `Ustr`.
pub type UstrFpCategory = FpCategory<Ustr, Ustr>;

impl<V, E> FpCategory<V, E>
where
    V: Eq + Clone + Hash,
    E: Eq + Clone + Hash,
{
    /// Gets the generating graph of the category presentation.
    pub fn generators(&self) -> &(impl FinGraph<V = V, E = E> + use<V, E>) {
        &self.generators
    }

    /// Gets the path equations of the category presentation.
    pub fn equations(&self) -> impl Iterator<Item = &PathEq<V, E>> {
        self.equations.iter()
    }

    /// Is the category freely generated?
    pub fn is_free(&self) -> bool {
        self.equations.is_empty()
    }

    /// Adds an object generator.
    pub fn add_ob_generator(&mut self, v: V) {
        assert!(self.generators.add_vertex(v.clone()), "Object generator already exists");
        self.builder.get_mut().add_ob_generator(v);
    }

    /// Adds several object generators at once.
    pub fn add_ob_generators(&mut self, iter: impl IntoIterator<Item = V>) {
        for v in iter {
            self.add_ob_generator(v)
        }
    }

    /// Adds a morphism generator.
    pub fn add_mor_generator(&mut self, e: E, dom: V, cod: V) {
        assert!(
            self.generators.add_edge(e.clone(), dom.clone(), cod.clone()),
            "Morphism generator already exists"
        );
        let (dom, cod) = (self.ob_generator_expr(dom), self.ob_generator_expr(cod));
        self.builder.get_mut().add_mor_generator(e, dom, cod);
    }

    /// Adds a morphism generator without declaring its (co)domain.
    pub fn make_mor_generator(&mut self, e: E) {
        assert!(self.generators.make_edge(e.clone()), "Morphism generator already exists");
        self.builder.get_mut().make_mor_generator(e);
    }

    /// Gets the domain of a morphism generator.
    pub fn get_dom(&self, e: &E) -> Option<&V> {
        self.generators.get_src(e)
    }

    /// Gets the codomain of a morphism generator.
    pub fn get_cod(&self, e: &E) -> Option<&V> {
        self.generators.get_tgt(e)
    }

    /// Sets the domain of a morphism generator.
    pub fn set_dom(&mut self, e: E, v: V) {
        assert!(
            self.generators.set_src(e.clone(), v.clone()).is_none(),
            "Domain of morphism generator should not already be set"
        );
        let (mor, ob) = (self.mor_generator_expr(e), self.ob_generator_expr(v));
        self.builder.get_mut().set_dom(mor, ob);
    }

    /// Sets the codomain of a morphism generator.
    pub fn set_cod(&mut self, e: E, v: V) {
        assert!(
            self.generators.set_tgt(e.clone(), v.clone()).is_none(),
            "Codomain of morphism generator should not already be set"
        );
        let (mor, ob) = (self.mor_generator_expr(e), self.ob_generator_expr(v));
        self.builder.get_mut().set_cod(mor, ob);
    }

    /// Adds a path equation to the presentation.
    pub fn add_equation(&mut self, eq: PathEq<V, E>) {
        self.equations.push(eq.clone());
        let (lhs, rhs) = (self.path_expr(eq.lhs), self.path_expr(eq.rhs));
        self.builder.get_mut().equate(lhs, rhs);
    }

    /// Equates two path in the presentation.
    pub fn equate(&mut self, lhs: Path<V, E>, rhs: Path<V, E>) {
        self.add_equation(PathEq::new(lhs, rhs));
    }

    fn ob_generator_expr(&self, v: V) -> Expr {
        self.builder.borrow_mut().ob_generator(v)
    }
    fn mor_generator_expr(&self, e: E) -> Expr {
        self.builder.borrow_mut().mor_generator(e)
    }
    fn path_expr(&self, path: Path<V, E>) -> Expr {
        path.map_reduce(
            |v| {
                let ob = self.ob_generator_expr(v);
                self.builder.borrow().id(ob)
            },
            |e| self.mor_generator_expr(e),
            |f, g| self.builder.borrow().compose2(f, g),
        )
    }

    /// Iterates over failures to be a well-defined presentation of a category.
    pub fn iter_invalid(&self) -> impl Iterator<Item = InvalidFpCategory<E>> + '_ {
        let generator_errors = self.generators.iter_invalid().map(|err| match err {
            InvalidGraph::Src(e) => InvalidFpCategory::Dom(e),
            InvalidGraph::Tgt(e) => InvalidFpCategory::Cod(e),
        });
        let equation_errors = self.equations.iter().enumerate().filter_map(|(i, eq)| {
            Some(InvalidFpCategory::Eq(i, eq.validate_in(&self.generators).err()?))
        });
        generator_errors.chain(equation_errors)
    }
}

impl<V, E> FpCategory<V, E>
where
    V: Eq + Clone + Hash,
    E: Eq + Clone + Hash,
{
    /// Reverse all of the generating morphisms
    /// On the free version this is based on (`reverse`)[`ReversibleGraph::reverse`]
    pub fn reverse_generating_morphisms(mut self) -> Self {
        let _old_builder = self.builder.take();
        let _old_egraph = self.egraph.take();
        self.generators = self.generators.reverse();
        let all_vertices: Vec<_> = self.generators.vertices().collect();
        for v in all_vertices {
            self.builder.get_mut().add_ob_generator(v);
        }
        let all_edges: Vec<_> = self.generators.edges().collect();
        for e in all_edges {
            let (dom, cod) = (self.generators.src(&e), self.generators.tgt(&e));
            let (dom, cod) = (self.ob_generator_expr(dom), self.ob_generator_expr(cod));
            self.builder.get_mut().add_mor_generator(e, dom, cod);
        }
        let mut all_equations = Vec::new();
        core::mem::swap(&mut all_equations, &mut self.equations);
        for equation in all_equations {
            self.add_equation(equation.reverse_both());
        }
        self
    }

    #[cfg(test)]
    fn new_free(generators: HashGraph<V, E>) -> Self {
        let mut new_self = Self::new();
        new_self.generators = generators;
        let all_vertices: Vec<_> = new_self.generators.vertices().collect();
        for v in all_vertices {
            new_self.builder.get_mut().add_ob_generator(v);
        }
        let all_edges: Vec<_> = new_self.generators.edges().collect();
        for e in all_edges {
            let (dom, cod) = (new_self.generators.src(&e), new_self.generators.tgt(&e));
            let (dom, cod) = (new_self.ob_generator_expr(dom), new_self.ob_generator_expr(cod));
            new_self.builder.get_mut().add_mor_generator(e, dom, cod);
        }
        new_self
    }
}

impl<V, E> Category for FpCategory<V, E>
where
    V: Eq + Clone + Hash,
    E: Eq + Clone + Hash,
{
    type Ob = V;
    type Mor = Path<V, E>;

    fn has_ob(&self, x: &Self::Ob) -> bool {
        self.generators.has_vertex(x)
    }
    fn has_mor(&self, path: &Self::Mor) -> bool {
        path.contained_in(&self.generators)
    }
    fn dom(&self, path: &Self::Mor) -> Self::Ob {
        path.src(&self.generators)
    }
    fn cod(&self, path: &Self::Mor) -> Self::Ob {
        path.tgt(&self.generators)
    }

    fn compose(&self, path: Path<Self::Ob, Self::Mor>) -> Self::Mor {
        path.flatten_in(&self.generators).expect("Paths should be composable")
    }
    fn compose2(&self, path1: Self::Mor, path2: Self::Mor) -> Self::Mor {
        path1
            .concat_in(&self.generators, path2)
            .expect("Target of first path should equal source of second path")
    }

    fn morphisms_are_equal(&self, path1: Self::Mor, path2: Self::Mor) -> bool {
        let (lhs, rhs) = (self.path_expr(path1), self.path_expr(path2));
        self.builder.borrow_mut().check_equal(lhs, rhs);
        self.builder
            .borrow_mut()
            .program()
            .check_in(&mut self.egraph.borrow_mut())
            .expect("Unexpected egglog error")
    }
}

impl<V, E> FgCategory for FpCategory<V, E>
where
    V: Eq + Clone + Hash,
    E: Eq + Clone + Hash,
{
    type ObGen = V;
    type MorGen = E;

    fn ob_generators(&self) -> impl Iterator<Item = Self::ObGen> {
        self.generators.vertices()
    }
    fn mor_generators(&self) -> impl Iterator<Item = Self::MorGen> {
        self.generators.edges()
    }
    fn mor_generator_dom(&self, f: &Self::MorGen) -> Self::Ob {
        self.generators.src(f)
    }
    fn mor_generator_cod(&self, f: &Self::MorGen) -> Self::Ob {
        self.generators.tgt(f)
    }
}

impl<V, E> Validate for FpCategory<V, E>
where
    V: Eq + Clone + Hash,
    E: Eq + Clone + Hash,
{
    type ValidationError = InvalidFpCategory<E>;

    fn validate(&self) -> Result<(), NonEmpty<Self::ValidationError>> {
        validate::wrap_errors(self.iter_invalid())
    }
}

/// A failure of a finite presentation of a category to be well defined.
#[derive(Debug, Error)]
pub enum InvalidFpCategory<E> {
    /// Morphism generator with an invalid domain.
    #[error("Domain of morphism generator `{0}` is not in the category")]
    Dom(E),

    /// Morphism generator with an invalid codomain.
    #[error("Codomain of morphism generator `{0}` is not in the category")]
    Cod(E),

    /// Path equation with one or more errors.
    #[error("Path equation `{0}` is not valid: `{1:?}`")]
    Eq(usize, NonEmpty<InvalidPathEq>),
}

/** Program builder for computing with categories in egglog.

Maintains an egglog [`Program`] as well as mappings from vertices and edges in
the category's generating graph to numeric IDs for generator terms in egglog. We
do not assume that vertices or edges can be converted to strings/symbols since
we want to support hierarchical naming, where names are a list of symbols.
 */
#[derive(Clone)]
struct CategoryProgramBuilder<V, E> {
    prog: Vec<Command>,
    sym: CategorySymbols,
    ob_generators: HashMap<V, usize>,
    mor_generators: HashMap<E, usize>,
}

impl<V, E> CategoryProgramBuilder<V, E>
where
    V: Eq + Hash,
    E: Eq + Hash,
{
    /// Declares an object generator.
    pub fn add_ob_generator(&mut self, v: V) -> usize {
        let id = self.ob_generator_id(v);
        let action = Action::Expr(span!(), self.ob_generator_with_id(id));
        self.prog.push(Command::Action(action));
        id
    }

    /// Declares a morphism generator and sets its domain and codmain.
    pub fn add_mor_generator(&mut self, e: E, dom: Expr, cod: Expr) -> usize {
        let id = self.make_mor_generator(e);
        self.set_dom(self.mor_generator_with_id(id), dom);
        self.set_cod(self.mor_generator_with_id(id), cod);
        id
    }

    /// Declares a morphism generator.
    pub fn make_mor_generator(&mut self, e: E) -> usize {
        let id = self.mor_generator_id(e);
        let action = Action::Expr(span!(), self.mor_generator_with_id(id));
        self.prog.push(Command::Action(action));
        id
    }

    /// Sets the domain of a morphism.
    pub fn set_dom(&mut self, mor: Expr, ob: Expr) {
        let dom = self.dom(mor);
        Program::ref_cast_mut(&mut self.prog).union(dom, ob);
    }

    /// Sets the codomain of a morphism.
    pub fn set_cod(&mut self, mor: Expr, ob: Expr) {
        let cod = self.cod(mor);
        Program::ref_cast_mut(&mut self.prog).union(cod, ob);
    }

    /// Constructs an object generator expression for the given vertex.
    pub fn ob_generator(&mut self, v: V) -> Expr {
        let id = self.ob_generator_id(v);
        self.ob_generator_with_id(id)
    }

    /// Gets or creates the internal ID for a given vertex.
    pub fn ob_generator_id(&mut self, v: V) -> usize {
        let n = self.ob_generators.len();
        *self.ob_generators.entry(v).or_insert(n)
    }

    /// Constructs a morphism generator expression for the given edge.
    pub fn mor_generator(&mut self, e: E) -> Expr {
        let id = self.mor_generator_id(e);
        self.mor_generator_with_id(id)
    }

    /// Gets or creates the internal ID for a given edge.
    pub fn mor_generator_id(&mut self, e: E) -> usize {
        let n = self.mor_generators.len();
        *self.mor_generators.entry(e).or_insert(n)
    }
}

impl<V, E> CategoryProgramBuilder<V, E> {
    /// Extracts the egglog program, consuming the cached statements.
    pub fn program(&mut self) -> Program {
        Program(std::mem::take(&mut self.prog))
    }

    /// Constructs an object generator call for the given internal ID.
    fn ob_generator_with_id(&self, id: usize) -> Expr {
        let id: i64 = id.try_into().expect("Shouldn't have too many object generators");
        call!(self.sym.ob_gen, vec![lit!(id)])
    }

    /// Constructs a morphism generator call for the given internal ID.
    fn mor_generator_with_id(&self, id: usize) -> Expr {
        let id: i64 = id.try_into().expect("Shouldn't have too many morphism generators");
        call!(self.sym.mor_gen, vec![lit!(id)])
    }

    /// Constructs a call of the morphism-is-valid predicate.
    pub fn mor_is_valid(&self, mor: Expr) -> Expr {
        call!(self.sym.mor_is_valid, vec![mor])
    }

    /// Constructs a domain call.
    pub fn dom(&self, mor: Expr) -> Expr {
        call!(self.sym.dom, vec![mor])
    }

    /// Constructs a codomain call.
    pub fn cod(&self, mor: Expr) -> Expr {
        call!(self.sym.cod, vec![mor])
    }

    /// Constructs an identity call.
    pub fn id(&self, ob: Expr) -> Expr {
        call!(self.sym.id, vec![ob])
    }

    /// Constructs a binary composition call.
    pub fn compose2(&self, f: Expr, g: Expr) -> Expr {
        call!(self.sym.compose, vec![f, g])
    }

    /// Equates two expressions in the category.
    pub fn equate(&mut self, lhs: Expr, rhs: Expr) {
        Program::ref_cast_mut(&mut self.prog).union(lhs, rhs);
    }

    /// Checks whether the expressions are equal.
    pub fn check_equal(&mut self, lhs: Expr, rhs: Expr) {
        let schedule = self.schedule();
        Program::ref_cast_mut(&mut self.prog).check_equal(lhs, rhs, Some(schedule));
    }

    /// Constructs a schedule to saturate the category axioms.
    fn schedule(&self) -> Schedule {
        Schedule::Saturate(
            span!(),
            Box::new(Schedule::Run(
                span!(),
                GenericRunConfig {
                    ruleset: self.sym.axioms,
                    until: None,
                },
            )),
        )
    }

    /// Generates the preamble for the program.
    fn preamble(&mut self) {
        let sym = &self.sym;
        self.prog = vec![
            // Types: objects and morphisms.
            Command::Datatype {
                span: span!(),
                name: sym.ob,
                variants: vec![Variant {
                    span: span!(),
                    name: sym.ob_gen,
                    types: vec!["i64".into()],
                    cost: Some(0),
                }],
            },
            Command::Datatype {
                span: span!(),
                name: sym.mor,
                variants: vec![Variant {
                    span: span!(),
                    name: sym.mor_gen,
                    types: vec!["i64".into()],
                    cost: Some(0),
                }],
            },
            // Constructors: (co)domain, identity, composition.
            Command::Constructor {
                span: span!(),
                name: sym.dom,
                schema: Schema {
                    input: vec![sym.mor],
                    output: sym.ob,
                },
                cost: Some(1),
                unextractable: false,
            },
            Command::Constructor {
                span: span!(),
                name: sym.cod,
                schema: Schema {
                    input: vec![sym.mor],
                    output: sym.ob,
                },
                cost: Some(1),
                unextractable: false,
            },
            Command::Constructor {
                span: span!(),
                name: sym.id,
                schema: Schema {
                    input: vec![sym.ob],
                    output: sym.mor,
                },
                cost: Some(1),
                unextractable: false,
            },
            Command::Constructor {
                span: span!(),
                name: sym.compose,
                schema: Schema {
                    input: vec![sym.mor, sym.mor],
                    output: sym.mor,
                },
                cost: Some(1),
                unextractable: false,
            },
            // Rule set: all the axioms for a category.
            Command::AddRuleset(sym.axioms),
            // Predicate: is the morphism well-typed?
            Command::Relation {
                span: span!(),
                name: sym.mor_is_valid,
                inputs: vec![sym.mor],
            },
            // Rule: every morphism generator is well-typed.
            Command::from(CommandRule {
                ruleset: sym.axioms,
                head: vec![Action::Expr(span!(), self.mor_is_valid(var!("f")))],
                body: vec![Fact::Eq(span!(), var!("f"), call!(sym.mor_gen, vec![var!("name")]))],
            }),
            // Rule: every identity morphism is well-typed.
            Command::from(CommandRule {
                ruleset: sym.axioms,
                head: vec![Action::Expr(span!(), self.mor_is_valid(var!("f")))],
                body: vec![Fact::Eq(span!(), var!("f"), self.id(var!("x")))],
            }),
            // Rule: a composite of two morphisms is well-typed if both
            // morphisms are well-typed and their (co)domains are compatible.
            Command::from(CommandRule {
                ruleset: sym.axioms,
                head: vec![Action::Expr(span!(), self.mor_is_valid(var!("fg")))],
                body: vec![
                    Fact::Eq(span!(), var!("fg"), self.compose2(var!("f"), var!("g"))),
                    Fact::Fact(self.mor_is_valid(var!("f"))),
                    Fact::Fact(self.mor_is_valid(var!("g"))),
                    Fact::Eq(span!(), self.cod(var!("f")), self.dom(var!("g"))),
                ],
            }),
            // Rules: (co)domains of composites and identities.
            Command::from(CommandRule {
                ruleset: sym.axioms,
                head: vec![
                    Action::Union(span!(), self.dom(var!("fg")), self.dom(var!("f"))),
                    Action::Union(span!(), self.cod(var!("fg")), self.cod(var!("g"))),
                ],
                body: vec![
                    Fact::Eq(span!(), var!("fg"), self.compose2(var!("f"), var!("g"))),
                    Fact::Fact(self.mor_is_valid(var!("fg"))),
                ],
            }),
            Command::from(CommandRewrite {
                ruleset: sym.axioms,
                lhs: self.dom(self.id(var!("x"))),
                rhs: var!("x"),
            }),
            Command::from(CommandRewrite {
                ruleset: sym.axioms,
                lhs: self.cod(self.id(var!("x"))),
                rhs: var!("x"),
            }),
            // Associativity and unitality axioms, where associativity is a
            // bidirectional rewrite and unitality is unidirectional rewrites.
            Command::from(CommandRule {
                ruleset: sym.axioms,
                head: vec![Action::Union(
                    span!(),
                    var!("fgh"),
                    self.compose2(var!("f"), self.compose2(var!("g"), var!("h"))),
                )],
                body: vec![
                    Fact::Eq(
                        span!(),
                        var!("fgh"),
                        self.compose2(self.compose2(var!("f"), var!("g")), var!("h")),
                    ),
                    Fact::Fact(self.mor_is_valid(var!("fgh"))),
                ],
            }),
            Command::from(CommandRule {
                ruleset: sym.axioms,
                head: vec![Action::Union(
                    span!(),
                    var!("fgh"),
                    self.compose2(self.compose2(var!("f"), var!("g")), var!("h")),
                )],
                body: vec![
                    Fact::Eq(
                        span!(),
                        var!("fgh"),
                        self.compose2(var!("f"), self.compose2(var!("g"), var!("h"))),
                    ),
                    Fact::Fact(self.mor_is_valid(var!("fgh"))),
                ],
            }),
            Command::from(CommandRewrite {
                ruleset: sym.axioms,
                lhs: self.compose2(var!("f"), self.id(self.cod(var!("f")))),
                rhs: var!("f"),
            }),
            Command::from(CommandRewrite {
                ruleset: sym.axioms,
                lhs: self.compose2(self.id(self.dom(var!("f"))), var!("f")),
                rhs: var!("f"),
            }),
        ]
    }
}

impl<V, E> Default for CategoryProgramBuilder<V, E> {
    fn default() -> Self {
        let mut result = Self {
            prog: Default::default(),
            sym: Default::default(),
            ob_generators: Default::default(),
            mor_generators: Default::default(),
        };
        result.preamble();
        result
    }
}

#[derive(Clone)]
struct CategorySymbols {
    ob: Symbol,
    mor: Symbol,
    mor_is_valid: Symbol,
    ob_gen: Symbol,
    mor_gen: Symbol,
    dom: Symbol,
    cod: Symbol,
    id: Symbol,
    compose: Symbol,
    axioms: Symbol,
}

impl Default for CategorySymbols {
    fn default() -> Self {
        Self {
            ob: "Ob".into(),
            mor: "Mor".into(),
            mor_is_valid: "is_mor_valid".into(),
            ob_gen: "ObGen".into(),
            mor_gen: "MorGen".into(),
            dom: "dom".into(),
            cod: "cod".into(),
            id: "id".into(),
            compose: "compose".into(),
            axioms: "CatAxioms".into(),
        }
    }
}

#[cfg(test)]
use ustr::ustr;

/// The schema for graphs, an f.p. category.
#[cfg(test)]
pub fn sch_graph() -> UstrFpCategory {
    let mut cat = UstrFpCategory::new();
    let (v, e) = (ustr("V"), ustr("E"));
    cat.add_ob_generators([v, e]);
    cat.add_mor_generator(ustr("src"), e, v);
    cat.add_mor_generator(ustr("tgt"), e, v);
    cat
}

/// The schema for symmetric graphs, an f.p. category.
#[cfg(test)]
pub fn sch_sgraph() -> UstrFpCategory {
    let mut cat = UstrFpCategory::new();
    let (v, e) = (ustr("V"), ustr("E"));
    let (s, t, i) = (ustr("src"), ustr("tgt"), ustr("inv"));
    cat.add_ob_generators([v, e]);
    cat.add_mor_generator(s, e, v);
    cat.add_mor_generator(t, e, v);
    cat.add_mor_generator(i, e, e);
    cat.equate(Path::pair(i, i), Path::empty(e));
    cat.equate(Path::pair(i, s), Path::single(t));
    cat.equate(Path::pair(i, t), Path::single(s));
    cat
}

/// The schema for half-edge graphs, an f.p. category.
#[cfg(test)]
pub fn sch_hgraph() -> UstrFpCategory {
    let mut cat = UstrFpCategory::new();
    let (v, h) = (ustr("V"), ustr("H"));
    let (vert, inv) = (ustr("vert"), ustr("inv"));
    cat.add_ob_generators([v, h]);
    cat.add_mor_generator(vert, h, v);
    cat.add_mor_generator(inv, h, h);
    cat.equate(Path::pair(inv, inv), Path::empty(h));
    cat
}

/// The schema for a freely generated category where the generating graph of the presentation
/// is a zig zag graph. This can be thought of as an orientation of an A_n quiver.
///
/// e.g. `0 -> 1 <- 2 -> 3 -> 4 <- 5` for `[true,false,true,true,false]`
///
/// It is also common to demand that all backwards arrows are actually isomorphisms. So we can alternatively
/// create the non-free version `0 -> 1 <-> 2 -> 3 -> 4 <-> 5` where the `<->` have the equation
/// that says they are inverses to each other.
#[cfg(test)]
fn sch_zigzag(
    quiver_orientation: impl ExactSizeIterator<Item = bool>,
    backwards_invertible: bool,
) -> UstrFpCategory {
    let mut cat = UstrFpCategory::new();
    let count_vertices = quiver_orientation.len() + 1;
    let mut vertex_names = Vec::with_capacity(count_vertices);
    for idx in 0..count_vertices {
        let cur_ustr: Ustr = format!("O{idx}").into();
        cat.add_ob_generator(cur_ustr);
        vertex_names.push(cur_ustr);
    }
    for (idx, current_orientation) in quiver_orientation.enumerate() {
        let cur_ustr: Ustr = format!("M{idx}").into();
        if current_orientation {
            cat.add_mor_generator(cur_ustr, vertex_names[idx], vertex_names[idx + 1]);
        } else {
            cat.add_mor_generator(cur_ustr, vertex_names[idx + 1], vertex_names[idx]);
            if backwards_invertible {
                let cur_ustr_inv: Ustr = format!("M{idx}^-1").into();
                cat.add_mor_generator(cur_ustr_inv, vertex_names[idx], vertex_names[idx + 1]);
                cat.equate(Path::pair(cur_ustr_inv, cur_ustr), Path::Id(vertex_names[idx]));
                cat.equate(Path::pair(cur_ustr, cur_ustr_inv), Path::Id(vertex_names[idx + 1]));
            }
        }
    }
    cat
}

/// The schema for a finitely generated category where the generating graph of the presentation
/// is as follows.
/// e.g. `-1 <- 0 <- <- 1 <- <- <- 2 <- <- <- <- 3`
/// as well as arrows the other way but with 1 fewer arrow in that direction.
///
/// The maps in the different directions are face maps and degeneracy maps.
///
/// There are many arrows with the same source and targets, but this is a feature of the difference
/// in what qualifies as a graph vs a multi-graph.
#[cfg(test)]
fn sch_simplicial(max_n: usize, is_augmented: bool) -> UstrFpCategory {
    let mut cat = UstrFpCategory::new();
    let mut vertex_names = Vec::with_capacity(max_n + 1 + usize::from(is_augmented));
    if is_augmented {
        let cur_ustr: Ustr = format!("O(-1)").into();
        cat.add_ob_generator(cur_ustr);
        vertex_names.push(cur_ustr);
    }
    for idx in 0..=max_n {
        let cur_ustr: Ustr = format!("O({idx})").into();
        cat.add_ob_generator(cur_ustr);
        vertex_names.push(cur_ustr);
    }
    let mut face_maps: Vec<Vec<Ustr>> = Vec::with_capacity(max_n + usize::from(is_augmented));
    let mut degen_maps: Vec<Vec<Ustr>> = Vec::with_capacity(max_n + usize::from(is_augmented));
    for idx in 0..max_n + usize::from(is_augmented) {
        let (src_n, src_obj, tgt_obj) = if is_augmented {
            (idx, vertex_names[idx + 1], vertex_names[idx])
        } else {
            (idx + 1, vertex_names[idx + 1], vertex_names[idx])
        };
        let mut face_maps_now = Vec::with_capacity(src_n + 1);
        for face_number in 0..=src_n {
            let cur_face_number: Ustr = format!("d({idx},{face_number})").into();
            cat.add_mor_generator(cur_face_number, src_obj, tgt_obj);
            face_maps_now.push(cur_face_number);
        }
        face_maps.push(face_maps_now);
        let mut degen_maps_now = Vec::with_capacity(src_n);
        for degen_number in 0..src_n {
            let cur_degen_number: Ustr = format!("s({idx},{degen_number})").into();
            cat.add_mor_generator(cur_degen_number, tgt_obj, src_obj);
            degen_maps_now.push(cur_degen_number);
        }
        degen_maps.push(degen_maps_now);
    }
    let how_many_faces_degens = face_maps.len();
    let count_ds = how_many_faces_degens;
    for n_idx in 0..count_ds - 1 {
        for j_idx in 0..face_maps[n_idx].len() {
            for i_idx in 0..=j_idx {
                cat.equate(
                    Path::pair(face_maps[n_idx + 1][i_idx], face_maps[n_idx][j_idx]),
                    Path::pair(face_maps[n_idx + 1][j_idx + 1], face_maps[n_idx][i_idx]),
                );
            }
        }
    }
    let count_ss = how_many_faces_degens;
    for n_idx in 0..count_ss - 1 {
        for j_idx in 0..degen_maps[n_idx].len() {
            for i_idx in 0..=j_idx {
                cat.equate(
                    Path::pair(degen_maps[n_idx][j_idx], degen_maps[n_idx + 1][i_idx]),
                    Path::pair(degen_maps[n_idx][i_idx], degen_maps[n_idx + 1][j_idx + 1]),
                );
            }
        }
    }
    for n_idx in 0..count_ss {
        for j_idx in 0..degen_maps[n_idx].len() {
            for i_idx in 0..face_maps[n_idx].len() {
                let lhs = Path::pair(degen_maps[n_idx][j_idx], face_maps[n_idx][i_idx]);
                if i_idx < j_idx {
                    if i_idx < face_maps[n_idx].len()
                        && n_idx > 0
                        && j_idx - 1 < degen_maps[n_idx - 1].len()
                    {
                        let rhs = Path::pair(
                            face_maps[n_idx - 1][i_idx],
                            degen_maps[n_idx - 1][j_idx - 1],
                        );
                        cat.equate(lhs, rhs);
                    }
                } else if i_idx == j_idx || i_idx == j_idx + 1 {
                    let rhs = Path::Id(lhs.src(cat.generators()));
                    cat.equate(lhs, rhs);
                } else {
                    if i_idx - 1 < face_maps[n_idx].len()
                        && n_idx > 0
                        && j_idx < degen_maps[n_idx - 1].len()
                    {
                        let rhs = Path::pair(
                            face_maps[n_idx - 1][i_idx - 1],
                            degen_maps[n_idx - 1][j_idx],
                        );
                        cat.equate(lhs, rhs);
                    }
                }
            }
        }
    }
    cat
}

#[cfg(test)]
mod tests {
    use super::*;
    use expect_test::expect;
    use nonempty::nonempty;
    use ustr::ustr;

    #[test]
    fn sch_sgraph_equations() {
        let sch_sgraph = sch_sgraph();
        assert!(!sch_sgraph.is_free());
        assert!(sch_sgraph.validate().is_ok());

        let (s, t, i) = (ustr("src"), ustr("tgt"), ustr("inv"));
        assert!(!sch_sgraph.morphisms_are_equal(Path::single(s), Path::single(t)));
        assert!(sch_sgraph.morphisms_are_equal(Path::pair(i, i), Path::empty(ustr("E"))));
        assert!(sch_sgraph.morphisms_are_equal(Path::Seq(nonempty![i, i, i, s]), Path::single(t)));
    }

    #[test]
    fn egraph_preamble() {
        let mut builder: CategoryProgramBuilder<char, char> = Default::default();
        let prog = builder.program();

        let expected = expect![[r#"
            (datatype Ob (ObGen i64 :cost 0))
            (datatype Mor (MorGen i64 :cost 0))
            (constructor dom (Mor) Ob :cost 1)
            (constructor cod (Mor) Ob :cost 1)
            (constructor id (Ob) Mor :cost 1)
            (constructor compose (Mor Mor) Mor :cost 1)
            (ruleset CatAxioms)
            (relation is_mor_valid (Mor))
            (rule ((= f (MorGen name)))
                  ((is_mor_valid f))
                    :ruleset CatAxioms )
            (rule ((= f (id x)))
                  ((is_mor_valid f))
                    :ruleset CatAxioms )
            (rule ((= fg (compose f g))
                   (is_mor_valid f)
                   (is_mor_valid g)
                   (= (cod f) (dom g)))
                  ((is_mor_valid fg))
                    :ruleset CatAxioms )
            (rule ((= fg (compose f g))
                   (is_mor_valid fg))
                  ((union (dom fg) (dom f))
                   (union (cod fg) (cod g)))
                    :ruleset CatAxioms )
            (rewrite (dom (id x)) x :ruleset CatAxioms)
            (rewrite (cod (id x)) x :ruleset CatAxioms)
            (rule ((= fgh (compose (compose f g) h))
                   (is_mor_valid fgh))
                  ((union fgh (compose f (compose g h))))
                    :ruleset CatAxioms )
            (rule ((= fgh (compose f (compose g h)))
                   (is_mor_valid fgh))
                  ((union fgh (compose (compose f g) h)))
                    :ruleset CatAxioms )
            (rewrite (compose f (id (cod f))) f :ruleset CatAxioms)
            (rewrite (compose (id (dom f)) f) f :ruleset CatAxioms)
        "#]];
        expected.assert_eq(&prog.to_string());

        let mut egraph: EGraph = Default::default();
        assert!(prog.run_in(&mut egraph).is_ok());
    }

    #[test]
    fn egraph_hgraph() {
        let sch_hgraph = sch_hgraph();
        assert!(!sch_hgraph.is_free());
        assert!(sch_hgraph.validate().is_ok());

        let mut builder: CategoryProgramBuilder<char, char> = Default::default();
        let prog = builder.program();
        let preamble = prog.to_string();

        let prog = sch_hgraph.builder.borrow_mut().program();

        let expected = expect![[r#"
            (ObGen 0)
            (ObGen 1)
            (MorGen 0)
            (union (dom (MorGen 0)) (ObGen 1))
            (union (cod (MorGen 0)) (ObGen 0))
            (MorGen 1)
            (union (dom (MorGen 1)) (ObGen 1))
            (union (cod (MorGen 1)) (ObGen 1))
            (union (compose (MorGen 1) (MorGen 1)) (id (ObGen 1)))
        "#]];
        let prog_string = prog.to_string();
        let (should_be_preamble, should_be_expected) = prog_string.split_at(preamble.len());
        expected.assert_eq(&should_be_expected);
        assert_eq!(should_be_preamble, preamble);

        let mut egraph: EGraph = Default::default();
        assert!(prog.run_in(&mut egraph).is_ok());
    }

    #[test]
    fn egraph_zigzag() {
        let sch_quiver = sch_zigzag([true, false, true, true, false].into_iter(), false);
        assert!(sch_quiver.is_free());
        assert!(sch_quiver.validate().is_ok());

        let mut builder: CategoryProgramBuilder<char, char> = Default::default();
        let prog = builder.program();
        let preamble = prog.to_string();

        let prog = sch_quiver.builder.borrow_mut().program();

        let expected = expect![[r#"
            (ObGen 0)
            (ObGen 1)
            (ObGen 2)
            (ObGen 3)
            (ObGen 4)
            (ObGen 5)
            (MorGen 0)
            (union (dom (MorGen 0)) (ObGen 0))
            (union (cod (MorGen 0)) (ObGen 1))
            (MorGen 1)
            (union (dom (MorGen 1)) (ObGen 2))
            (union (cod (MorGen 1)) (ObGen 1))
            (MorGen 2)
            (union (dom (MorGen 2)) (ObGen 2))
            (union (cod (MorGen 2)) (ObGen 3))
            (MorGen 3)
            (union (dom (MorGen 3)) (ObGen 3))
            (union (cod (MorGen 3)) (ObGen 4))
            (MorGen 4)
            (union (dom (MorGen 4)) (ObGen 5))
            (union (cod (MorGen 4)) (ObGen 4))
        "#]];
        let prog_string = prog.to_string();
        let (should_be_preamble, should_be_expected) = prog_string.split_at(preamble.len());
        expected.assert_eq(&should_be_expected);
        assert_eq!(should_be_preamble, preamble);

        let mut egraph: EGraph = Default::default();
        assert!(prog.run_in(&mut egraph).is_ok());
    }

    #[test]
    fn egraph_zigzag_equivalences() {
        let sch_quiver = sch_zigzag([true, false, true, true, false].into_iter(), true);
        assert!(!sch_quiver.is_free());
        assert!(sch_quiver.validate().is_ok());

        let mut builder: CategoryProgramBuilder<char, char> = Default::default();
        let prog = builder.program();
        let preamble = prog.to_string();

        let prog = sch_quiver.builder.borrow_mut().program();

        let expected = expect![[r#"
            (ObGen 0)
            (ObGen 1)
            (ObGen 2)
            (ObGen 3)
            (ObGen 4)
            (ObGen 5)
            (MorGen 0)
            (union (dom (MorGen 0)) (ObGen 0))
            (union (cod (MorGen 0)) (ObGen 1))
            (MorGen 1)
            (union (dom (MorGen 1)) (ObGen 2))
            (union (cod (MorGen 1)) (ObGen 1))
            (MorGen 2)
            (union (dom (MorGen 2)) (ObGen 1))
            (union (cod (MorGen 2)) (ObGen 2))
            (union (compose (MorGen 2) (MorGen 1)) (id (ObGen 1)))
            (union (compose (MorGen 1) (MorGen 2)) (id (ObGen 2)))
            (MorGen 3)
            (union (dom (MorGen 3)) (ObGen 2))
            (union (cod (MorGen 3)) (ObGen 3))
            (MorGen 4)
            (union (dom (MorGen 4)) (ObGen 3))
            (union (cod (MorGen 4)) (ObGen 4))
            (MorGen 5)
            (union (dom (MorGen 5)) (ObGen 5))
            (union (cod (MorGen 5)) (ObGen 4))
            (MorGen 6)
            (union (dom (MorGen 6)) (ObGen 4))
            (union (cod (MorGen 6)) (ObGen 5))
            (union (compose (MorGen 6) (MorGen 5)) (id (ObGen 4)))
            (union (compose (MorGen 5) (MorGen 6)) (id (ObGen 5)))
        "#]];
        let prog_string = prog.to_string();
        let (should_be_preamble, should_be_expected) = prog_string.split_at(preamble.len());
        expected.assert_eq(&should_be_expected);
        assert_eq!(should_be_preamble, preamble);

        let mut egraph: EGraph = Default::default();
        assert!(prog.run_in(&mut egraph).is_ok());
    }

    #[test]
    fn egraph_simplicial() {
        let sch_quiver = sch_simplicial(2, false);
        assert!(!sch_quiver.is_free());
        let validation = sch_quiver.validate();
        match validation {
            Ok(_) => {}
            Err(all_the_errors) => {
                for cur_error in all_the_errors {
                    println!("{}", cur_error);
                }
                panic!("Had at least one error");
            }
        }

        let mut builder: CategoryProgramBuilder<char, char> = Default::default();
        let prog = builder.program();
        let preamble = prog.to_string();

        let prog = sch_quiver.builder.borrow_mut().program();

        // Mor 0,1 are d^2_0, d^2_1
        // Mor 2 is s^1_0
        // Mor 3,4,5 are d^3_0, d^3_1, d^3_2
        // Mor 6,7 are s^2_0, s^2_1
        // so we should get
        // 3,0 = 4,0 for d^3_0 d^2_0 = d^3_1 d^2_0
        // 3,1 = 5,0 for d^3_0 d^2_1 = d^3_2 d^2_0
        // 4,1 = 5,1 for d^3_1 d^2_1 = d^3_2 d^2_1
        // 2,6 = 2,7 for s^1_0 s^2_0 = s^1_0 s^2_1
        // 2,0 = id for s^1_0 d^2_0
        // 2,1 = id for s^1_0 d^2_1
        // 6,3 = id for s^2_0 d^3_0
        // 6,4 = id for s^2_0 d^3_1
        // 6,5 = 1,2 for s^2_0 d^3_2 = d^2_1 s^1_0
        // 7,3 = 0,2 for s^2_1 d^3_0 = d^2_0 s^1_0
        // 7,4 = id for s^2_1 d^3_1
        // 7,5 = id for s^2_1 d^3_2
        let expected = expect![[r#"
            (ObGen 0)
            (ObGen 1)
            (ObGen 2)
            (MorGen 0)
            (union (dom (MorGen 0)) (ObGen 1))
            (union (cod (MorGen 0)) (ObGen 0))
            (MorGen 1)
            (union (dom (MorGen 1)) (ObGen 1))
            (union (cod (MorGen 1)) (ObGen 0))
            (MorGen 2)
            (union (dom (MorGen 2)) (ObGen 0))
            (union (cod (MorGen 2)) (ObGen 1))
            (MorGen 3)
            (union (dom (MorGen 3)) (ObGen 2))
            (union (cod (MorGen 3)) (ObGen 1))
            (MorGen 4)
            (union (dom (MorGen 4)) (ObGen 2))
            (union (cod (MorGen 4)) (ObGen 1))
            (MorGen 5)
            (union (dom (MorGen 5)) (ObGen 2))
            (union (cod (MorGen 5)) (ObGen 1))
            (MorGen 6)
            (union (dom (MorGen 6)) (ObGen 1))
            (union (cod (MorGen 6)) (ObGen 2))
            (MorGen 7)
            (union (dom (MorGen 7)) (ObGen 1))
            (union (cod (MorGen 7)) (ObGen 2))
            (union (compose (MorGen 3) (MorGen 0)) (compose (MorGen 4) (MorGen 0)))
            (union (compose (MorGen 3) (MorGen 1)) (compose (MorGen 5) (MorGen 0)))
            (union (compose (MorGen 4) (MorGen 1)) (compose (MorGen 5) (MorGen 1)))
            (union (compose (MorGen 2) (MorGen 6)) (compose (MorGen 2) (MorGen 7)))
            (union (compose (MorGen 2) (MorGen 0)) (id (ObGen 0)))
            (union (compose (MorGen 2) (MorGen 1)) (id (ObGen 0)))
            (union (compose (MorGen 6) (MorGen 3)) (id (ObGen 1)))
            (union (compose (MorGen 6) (MorGen 4)) (id (ObGen 1)))
            (union (compose (MorGen 6) (MorGen 5)) (compose (MorGen 1) (MorGen 2)))
            (union (compose (MorGen 7) (MorGen 3)) (compose (MorGen 0) (MorGen 2)))
            (union (compose (MorGen 7) (MorGen 4)) (id (ObGen 1)))
            (union (compose (MorGen 7) (MorGen 5)) (id (ObGen 1)))
        "#]];
        let prog_string = prog.to_string();
        let (should_be_preamble, should_be_expected) = prog_string.split_at(preamble.len());
        expected.assert_eq(&should_be_expected);
        assert_eq!(should_be_preamble, preamble);

        let mut egraph: EGraph = Default::default();
        assert!(prog.run_in(&mut egraph).is_ok());
    }

    #[test]
    fn egraph_simplicial_augmented() {
        let sch_quiver = sch_simplicial(2, true);
        assert!(!sch_quiver.is_free());
        assert!(sch_quiver.validate().is_ok());

        let mut builder: CategoryProgramBuilder<char, char> = Default::default();
        let prog = builder.program();
        let preamble = prog.to_string();

        let prog = sch_quiver.builder.borrow_mut().program();

        // Mor 0 is d^1_0
        // Mor 1,2 are d^2_0, d^2_1
        // Mor 3 is s^1_0
        // Mor 4,5,6 are d^3_0, d^3_1, d^3_2
        // Mor 7,8 are s^2_0, s^2_1
        // so we should get
        // 1,0 = 2,0 for d^2_0 d^1_0 = d^2_1 d^1_0
        // 4,1 = 5,1 for d^3_0 d^2_0 = d^3_1 d^2_0
        // 4,2 = 6,1 for d^3_0 d^2_1 = d^3_2 d^2_0
        // 5,2 = 6,2 for d^3_1 d^2_1 = d^3_2 d^2_1
        // 3,7 = 3,8 for s^1_0 s^2_0 = s^1_0 s^2_1
        // 3,1 = id for s^1_0 d^2_0
        // 3,2 = id for s^1_0 d^2_1
        // 7,4 = id for s^2_0 d^3_0
        // 7,5 = id for s^2_0 d^3_1
        // 7,6 = 2,3 for s^2_0 d^3_2 = d^2_1 s^1_0
        // 8,4 = 1,3 for s^2_1 d^3_0 = d^2_0 s^1_0
        // 8,5 = id for s^2_1 d^3_1
        // 8,6 = id for s^2_1 d^3_2
        let expected = expect![[r#"
            (ObGen 0)
            (ObGen 1)
            (ObGen 2)
            (ObGen 3)
            (MorGen 0)
            (union (dom (MorGen 0)) (ObGen 1))
            (union (cod (MorGen 0)) (ObGen 0))
            (MorGen 1)
            (union (dom (MorGen 1)) (ObGen 2))
            (union (cod (MorGen 1)) (ObGen 1))
            (MorGen 2)
            (union (dom (MorGen 2)) (ObGen 2))
            (union (cod (MorGen 2)) (ObGen 1))
            (MorGen 3)
            (union (dom (MorGen 3)) (ObGen 1))
            (union (cod (MorGen 3)) (ObGen 2))
            (MorGen 4)
            (union (dom (MorGen 4)) (ObGen 3))
            (union (cod (MorGen 4)) (ObGen 2))
            (MorGen 5)
            (union (dom (MorGen 5)) (ObGen 3))
            (union (cod (MorGen 5)) (ObGen 2))
            (MorGen 6)
            (union (dom (MorGen 6)) (ObGen 3))
            (union (cod (MorGen 6)) (ObGen 2))
            (MorGen 7)
            (union (dom (MorGen 7)) (ObGen 2))
            (union (cod (MorGen 7)) (ObGen 3))
            (MorGen 8)
            (union (dom (MorGen 8)) (ObGen 2))
            (union (cod (MorGen 8)) (ObGen 3))
            (union (compose (MorGen 1) (MorGen 0)) (compose (MorGen 2) (MorGen 0)))
            (union (compose (MorGen 4) (MorGen 1)) (compose (MorGen 5) (MorGen 1)))
            (union (compose (MorGen 4) (MorGen 2)) (compose (MorGen 6) (MorGen 1)))
            (union (compose (MorGen 5) (MorGen 2)) (compose (MorGen 6) (MorGen 2)))
            (union (compose (MorGen 3) (MorGen 7)) (compose (MorGen 3) (MorGen 8)))
            (union (compose (MorGen 3) (MorGen 1)) (id (ObGen 1)))
            (union (compose (MorGen 3) (MorGen 2)) (id (ObGen 1)))
            (union (compose (MorGen 7) (MorGen 4)) (id (ObGen 2)))
            (union (compose (MorGen 7) (MorGen 5)) (id (ObGen 2)))
            (union (compose (MorGen 7) (MorGen 6)) (compose (MorGen 2) (MorGen 3)))
            (union (compose (MorGen 8) (MorGen 4)) (compose (MorGen 1) (MorGen 3)))
            (union (compose (MorGen 8) (MorGen 5)) (id (ObGen 2)))
            (union (compose (MorGen 8) (MorGen 6)) (id (ObGen 2)))
        "#]];
        let prog_string = prog.to_string();
        let (should_be_preamble, should_be_expected) = prog_string.split_at(preamble.len());
        expected.assert_eq(&should_be_expected);
        assert_eq!(should_be_preamble, preamble);

        let mut egraph: EGraph = Default::default();
        assert!(prog.run_in(&mut egraph).is_ok());
    }

    #[test]
    fn small_reversed() {
        let sch_graph_before = sch_graph();
        let sch_graph_after = sch_graph().reverse_generating_morphisms();
        for old_obj in sch_graph_before.objects() {
            assert!(sch_graph_after.has_ob(&old_obj));
        }
        for old_morphism in sch_graph_before.morphisms() {
            assert!(sch_graph_after.has_mor(&old_morphism));
            assert_eq!(sch_graph_after.dom(&old_morphism), sch_graph_before.cod(&old_morphism));
            assert_eq!(sch_graph_after.cod(&old_morphism), sch_graph_before.dom(&old_morphism));
        }

        let sch_graph_before = sch_hgraph();
        let sch_graph_after = sch_hgraph().reverse_generating_morphisms();
        for old_obj in sch_graph_before.objects() {
            assert!(sch_graph_after.has_ob(&old_obj));
        }
        for old_morphism in sch_graph_before.morphisms() {
            assert!(sch_graph_after.has_mor(&old_morphism));
            assert_eq!(sch_graph_after.dom(&old_morphism), sch_graph_before.cod(&old_morphism));
            assert_eq!(sch_graph_after.cod(&old_morphism), sch_graph_before.dom(&old_morphism));
        }
    }

    #[test]
    fn egraph_simplicial_reversed() {
        let sch_quiver = sch_simplicial(2, true).reverse_generating_morphisms();
        let validation = sch_quiver.validate();
        match validation {
            Ok(_) => {}
            Err(the_errs) => {
                for err in the_errs {
                    println!("{}", err);
                }
                panic!("At least one error");
            }
        }
        assert!(!sch_quiver.is_free());
        let prog = sch_quiver.builder.borrow_mut().program();
        let mut egraph: EGraph = Default::default();
        assert!(prog.run_in(&mut egraph).is_ok());

        let sch_quiver = sch_simplicial(2, false).reverse_generating_morphisms();
        assert!(sch_quiver.validate().is_ok());
        assert!(!sch_quiver.is_free());
        let prog = sch_quiver.builder.borrow_mut().program();
        let mut egraph: EGraph = Default::default();
        assert!(prog.run_in(&mut egraph).is_ok());
    }
}

#[cfg(test)]
mod proptesting {
    use super::{FgCategory, FpCategory};
    use crate::one::graph::{FinGraph, proptesting::hash_graph_strategy};
    use crate::validate::Validate;
    use proptest::{prop_assert, proptest};

    proptest! {
        #[test]
        fn freely_generated_but_messy(hg in hash_graph_strategy(
            proptest::sample::size_range(0..50),
            -100i32..=50,
            10usize..100,
            0i8..10,
        )) {
            prop_assert!(hg.validate().is_ok());
            let num_v = hg.vertex_count();
            let num_e = hg.edge_count();
            let free_cat = FpCategory::new_free(hg);
            prop_assert!(free_cat.validate().is_ok());
            prop_assert!(free_cat.is_free());
            prop_assert!(free_cat.ob_generators().count() == num_v);
            prop_assert!(free_cat.mor_generators().count() == num_e);
        }
    }
}
