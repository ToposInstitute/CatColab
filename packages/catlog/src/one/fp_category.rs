/*! Finitely presented categories.

A *finitely presented category*, or *f.p. category* for short, is a [finite
graph](super::graph::FinGraph) together with a finite set of [path
equations](super::path::PathEq). This data defines a category whose objects are
the vertices of the graph and morphisms are paths in the graphs, regarded as
equivalent under the congruence relation generated by the path equations. For a
detailed description of this congruence relation, see ([Spivak
2014](crate::refs::CTForTheSciences), Definition 4.5.2.3).

In general, this congruence relation---the word problem for finitely presented
categories---cannot be decided, though in practice it often can be. The data
structure in this module uses [e-graphs](https://en.wikipedia.org/wiki/E-graph)
to check for equivalence of paths under the congruence.
 */

use std::cell::RefCell;
use std::fmt::Debug;
use std::hash::{BuildHasher, BuildHasherDefault, Hash, RandomState};

use derivative::Derivative;
use egglog::ast::{
    Action, Command, Expr, GenericRunConfig, Rewrite, Schedule, Schema, Symbol, Variant,
};
use egglog::{EGraph, call, lit, span, var};
use nonempty::NonEmpty;
use ref_cast::RefCast;
use thiserror::Error;
use ustr::{IdentityHasher, Ustr};

use super::{category::*, graph::*, path::*};
use crate::egglog_util::{Program, ToSymbol};
use crate::validate::{self, Validate};

/** A finitely presented category backed by an e-graph.

A data structure for a f.p. category in which the congruence relation generated
by the path equations is maintained by an e-graph. The question of whether paths
in the presented category are equivalent is referred to the e-graph.

# Thread safety

Checking equivalence of paths requires mutating the underlying e-graph. However,
we do not want to regard this check as mutating, for the theoretical reason that
the check does not change the category presented and the practical reason that
it would cause mutable references to be aggressively propagated throughout the
codebase. Thus, we use the [interior
mutability](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html)
pattern to encapsulate the mutability of the e-graph and perform borrow checking
at runtime. The current implementation allows only *single-threaded* usage.
 */
#[derive(Clone, Derivative)]
#[derivative(Debug(bound = "V: Debug, E: Debug, S: Debug"))]
#[derivative(Default(bound = "S: Default"))]
#[derivative(PartialEq(bound = "V: Eq + Hash, E: Eq + Hash, S: BuildHasher"))]
#[derivative(Eq(bound = "V: Eq + Hash, E: Eq + Hash, S: BuildHasher"))]
pub struct FpCategory<V, E, S = RandomState> {
    generators: HashGraph<V, E, S>,
    equations: Vec<PathEq<V, E>>,
    #[derivative(Debug = "ignore", PartialEq = "ignore")]
    builder: RefCell<CategoryProgramBuilder>,
    #[derivative(Debug = "ignore", PartialEq = "ignore")]
    egraph: RefCell<EGraph>,
}

/// A finitely presented category with generators of type `Ustr`.
pub type UstrFpCategory = FpCategory<Ustr, Ustr, BuildHasherDefault<IdentityHasher>>;

impl<V, E, S> FpCategory<V, E, S>
where
    V: Eq + Clone + Hash + ToSymbol,
    E: Eq + Clone + Hash + ToSymbol,
    S: BuildHasher,
{
    /// Gets the generating graph of the category presentation.
    pub fn generators(&self) -> &(impl FinGraph<V = V, E = E> + use<V, E, S>) {
        &self.generators
    }

    /// Gets the path equations of the category presentation.
    pub fn equations(&self) -> impl Iterator<Item = &PathEq<V, E>> {
        self.equations.iter()
    }

    /// Is the category freely generated?
    pub fn is_free(&self) -> bool {
        self.equations.is_empty()
    }

    /// Adds an object generator.
    pub fn add_ob_generator(&mut self, v: V) {
        assert!(self.generators.add_vertex(v.clone()), "Object generator already exists");
        self.builder.get_mut().add_ob_generator(v.to_symbol());
    }

    /// Adds several object generators at once.
    pub fn add_ob_generators(&mut self, iter: impl IntoIterator<Item = V>) {
        for v in iter {
            self.add_ob_generator(v)
        }
    }

    /// Adds a morphism generator.
    pub fn add_mor_generator(&mut self, e: E, dom: V, cod: V) {
        assert!(
            self.generators.add_edge(e.clone(), dom.clone(), cod.clone()),
            "Morphism generator already exists"
        );
        let (dom, cod) = (self.ob_generator_expr(dom), self.ob_generator_expr(cod));
        self.builder.get_mut().add_mor_generator(e.to_symbol(), dom, cod);
    }

    /// Adds a morphism generator without declaring its (co)domain.
    pub fn make_mor_generator(&mut self, e: E) {
        assert!(self.generators.make_edge(e.clone()), "Morphism generator already exists");
        self.builder.get_mut().make_mor_generator(e.to_symbol());
    }

    /// Gets the domain of a morphism generator.
    pub fn get_dom(&self, e: &E) -> Option<&V> {
        self.generators.get_src(e)
    }

    /// Gets the codomain of a morphism generator.
    pub fn get_cod(&self, e: &E) -> Option<&V> {
        self.generators.get_tgt(e)
    }

    /// Sets the domain of a morphism generator.
    pub fn set_dom(&mut self, e: E, v: V) {
        assert!(
            self.generators.set_src(e.clone(), v.clone()).is_none(),
            "Domain of morphism generator should not already be set"
        );
        let (mor, ob) = (self.mor_generator_expr(e), self.ob_generator_expr(v));
        self.builder.get_mut().set_dom(mor, ob);
    }

    /// Sets the codomain of a morphism generator.
    pub fn set_cod(&mut self, e: E, v: V) {
        assert!(
            self.generators.set_tgt(e.clone(), v.clone()).is_none(),
            "Codomain of morphism generator should not already be set"
        );
        let (mor, ob) = (self.mor_generator_expr(e), self.ob_generator_expr(v));
        self.builder.get_mut().set_cod(mor, ob);
    }

    /// Adds a path equation to the presentation.
    pub fn add_equation(&mut self, eq: PathEq<V, E>) {
        self.equations.push(eq.clone());
        let (lhs, rhs) = (self.path_expr(eq.lhs), self.path_expr(eq.rhs));
        self.builder.get_mut().equate(lhs, rhs);
    }

    /// Equates two path in the presentation.
    pub fn equate(&mut self, lhs: Path<V, E>, rhs: Path<V, E>) {
        self.add_equation(PathEq::new(lhs, rhs));
    }

    fn ob_generator_expr(&self, v: V) -> Expr {
        self.builder.borrow().ob_generator(v.to_symbol())
    }
    fn mor_generator_expr(&self, e: E) -> Expr {
        self.builder.borrow().mor_generator(e.to_symbol())
    }
    fn path_expr(&self, path: Path<V, E>) -> Expr {
        let builder = self.builder.borrow();
        path.map_reduce(
            |v| builder.id(self.ob_generator_expr(v)),
            |e| self.mor_generator_expr(e),
            |f, g| builder.compose2(f, g),
        )
    }

    /// Iterates over failures to be a well-defined presentation of a category.
    pub fn iter_invalid(&self) -> impl Iterator<Item = InvalidFpCategory<E>> + '_ {
        let generator_errors = self.generators.iter_invalid().map(|err| match err {
            InvalidGraphData::Src(e) => InvalidFpCategory::Dom(e),
            InvalidGraphData::Tgt(e) => InvalidFpCategory::Cod(e),
        });
        let equation_errors = self.equations.iter().enumerate().flat_map(|(i, eq)| {
            eq.iter_invalid_in(&self.generators).map(move |err| match err {
                InvalidPathEq::Lhs() => InvalidFpCategory::EqLhs(i),
                InvalidPathEq::Rhs() => InvalidFpCategory::EqRhs(i),
                InvalidPathEq::Src() => InvalidFpCategory::EqSrc(i),
                InvalidPathEq::Tgt() => InvalidFpCategory::EqTgt(i),
            })
        });
        generator_errors.chain(equation_errors)
    }
}

impl<V, E, S> Category for FpCategory<V, E, S>
where
    V: Eq + Clone + Hash + ToSymbol,
    E: Eq + Clone + Hash + ToSymbol,
    S: BuildHasher,
{
    type Ob = V;
    type Mor = Path<V, E>;

    fn has_ob(&self, x: &Self::Ob) -> bool {
        self.generators.has_vertex(x)
    }
    fn has_mor(&self, path: &Self::Mor) -> bool {
        path.contained_in(&self.generators)
    }
    fn dom(&self, path: &Self::Mor) -> Self::Ob {
        path.src(&self.generators)
    }
    fn cod(&self, path: &Self::Mor) -> Self::Ob {
        path.tgt(&self.generators)
    }

    fn compose(&self, path: Path<Self::Ob, Self::Mor>) -> Self::Mor {
        path.flatten_in(&self.generators).expect("Paths should be composable")
    }
    fn compose2(&self, path1: Self::Mor, path2: Self::Mor) -> Self::Mor {
        path1
            .concat_in(&self.generators, path2)
            .expect("Target of first path should equal source of second path")
    }

    fn morphisms_are_equal(&self, path1: Self::Mor, path2: Self::Mor) -> bool {
        let (lhs, rhs) = (self.path_expr(path1), self.path_expr(path2));
        self.builder.borrow_mut().check_equal(lhs, rhs);
        self.builder
            .borrow_mut()
            .program()
            .check_in(&mut self.egraph.borrow_mut())
            .expect("Unexpected egglog error")
    }
}

impl<V, E, S> FgCategory for FpCategory<V, E, S>
where
    V: Eq + Clone + Hash + ToSymbol,
    E: Eq + Clone + Hash + ToSymbol,
    S: BuildHasher,
{
    type ObGen = V;
    type MorGen = E;

    fn ob_generators(&self) -> impl Iterator<Item = Self::ObGen> {
        self.generators.vertices()
    }
    fn mor_generators(&self) -> impl Iterator<Item = Self::MorGen> {
        self.generators.edges()
    }
    fn mor_generator_dom(&self, f: &Self::MorGen) -> Self::Ob {
        self.generators.src(f)
    }
    fn mor_generator_cod(&self, f: &Self::MorGen) -> Self::Ob {
        self.generators.tgt(f)
    }
}

impl<V, E, S> Validate for FpCategory<V, E, S>
where
    V: Eq + Clone + Hash + ToSymbol,
    E: Eq + Clone + Hash + ToSymbol,
    S: BuildHasher,
{
    type ValidationError = InvalidFpCategory<E>;

    fn validate(&self) -> Result<(), NonEmpty<Self::ValidationError>> {
        validate::wrap_errors(self.iter_invalid())
    }
}

/// A failure of a finite presentation of a category to be well defined.
#[derive(Debug, Error)]
pub enum InvalidFpCategory<E> {
    /// Morphism generator assigned a domain not contained in the category.
    #[error("Domain of morphism generator `{0}` is not in the category")]
    Dom(E),

    /// Morphism generator assigned a codomain not contained in the category.
    #[error("Codomain of morphism generator `{0}` is not in the category")]
    Cod(E),

    /// Path in left hand side of equation not contained in the category.
    #[error("LHS of path equation `{0}` is not in the category")]
    EqLhs(usize),

    /// Path in right hand side of equation not contained in the category.
    #[error("RHS of path equation `{0}` is not in the category")]
    EqRhs(usize),

    /// Sources of left and right hand sides of path equation are not equal.
    #[error("Path equation `{0}` has sources that are not equal")]
    EqSrc(usize),

    /// Targets of left and right hand sides of path equation are not equal.
    #[error("Path equation `{0}` has targets that are not equal")]
    EqTgt(usize),
}

/// Program builder for computing with categories in egglog.
#[derive(Clone)]
struct CategoryProgramBuilder {
    prog: Vec<Command>,
    sym: CategorySymbols,
}

impl CategoryProgramBuilder {
    /// Extracts the egglog program, consuming the cached statements.
    pub fn program(&mut self) -> Program {
        Program(std::mem::take(&mut self.prog))
    }

    /// Declares an object generator.
    pub fn add_ob_generator(&mut self, name: Symbol) {
        let action = Action::Expr(span!(), self.ob_generator(name));
        self.prog.push(Command::Action(action));
    }

    /// Declares a morphism generator and sets its domain and codmain.
    pub fn add_mor_generator(&mut self, name: Symbol, dom: Expr, cod: Expr) {
        self.make_mor_generator(name);
        self.set_dom(self.mor_generator(name), dom);
        self.set_cod(self.mor_generator(name), cod);
    }

    /// Declares a morphism generator.
    pub fn make_mor_generator(&mut self, name: Symbol) {
        let action = Action::Expr(span!(), self.mor_generator(name));
        self.prog.push(Command::Action(action));
    }

    /// Sets the domain of a morphism.
    pub fn set_dom(&mut self, mor: Expr, ob: Expr) {
        let dom = self.dom(mor);
        Program::ref_cast_mut(&mut self.prog).union(dom, ob);
    }

    /// Sets the codomain of a morphism.
    pub fn set_cod(&mut self, mor: Expr, ob: Expr) {
        let cod = self.cod(mor);
        Program::ref_cast_mut(&mut self.prog).union(cod, ob);
    }

    /// Constructs an object generator expression.
    pub fn ob_generator(&self, name: Symbol) -> Expr {
        call!(self.sym.ob_gen, vec![lit!(name)])
    }

    /// Constructors a morphism generator expression.
    pub fn mor_generator(&self, name: Symbol) -> Expr {
        call!(self.sym.mor_gen, vec![lit!(name)])
    }

    /// Constructs a domain call.
    pub fn dom(&self, mor: Expr) -> Expr {
        call!(self.sym.dom, vec![mor])
    }

    /// Constructs a codomain call.
    pub fn cod(&self, mor: Expr) -> Expr {
        call!(self.sym.cod, vec![mor])
    }

    /// Constructs an identity call.
    pub fn id(&self, ob: Expr) -> Expr {
        call!(self.sym.id, vec![ob])
    }

    /// Constructs a binary composition call.
    pub fn compose2(&self, f: Expr, g: Expr) -> Expr {
        call!(self.sym.compose, vec![f, g])
    }

    /// Equates two expressions in the category.
    pub fn equate(&mut self, lhs: Expr, rhs: Expr) {
        Program::ref_cast_mut(&mut self.prog).union(lhs, rhs);
    }

    /// Checks whether the expressions are equal.
    pub fn check_equal(&mut self, lhs: Expr, rhs: Expr) {
        let schedule = self.schedule();
        Program::ref_cast_mut(&mut self.prog).check_equal(lhs, rhs, Some(schedule));
    }

    /// Constructs a schedule to saturate the category axioms.
    fn schedule(&self) -> Schedule {
        Schedule::Saturate(
            span!(),
            Box::new(Schedule::Run(
                span!(),
                GenericRunConfig {
                    ruleset: self.sym.axioms,
                    until: None,
                },
            )),
        )
    }

    /// Generates the preamble for the program.
    fn preamble(&mut self) {
        let sym = &self.sym;
        self.prog = vec![
            // Type and term constructors.
            Command::Datatype {
                span: span!(),
                name: sym.ob,
                variants: vec![Variant {
                    span: span!(),
                    name: sym.ob_gen,
                    types: vec!["String".into()],
                    cost: Some(0),
                }],
            },
            Command::Datatype {
                span: span!(),
                name: sym.mor,
                variants: vec![Variant {
                    span: span!(),
                    name: sym.mor_gen,
                    types: vec!["String".into()],
                    cost: Some(0),
                }],
            },
            Command::Constructor {
                span: span!(),
                name: sym.dom,
                schema: Schema {
                    input: vec![sym.mor],
                    output: sym.ob,
                },
                cost: Some(1),
                unextractable: false,
            },
            Command::Constructor {
                span: span!(),
                name: sym.cod,
                schema: Schema {
                    input: vec![sym.mor],
                    output: sym.ob,
                },
                cost: Some(1),
                unextractable: false,
            },
            Command::Constructor {
                span: span!(),
                name: sym.id,
                schema: Schema {
                    input: vec![sym.ob],
                    output: sym.mor,
                },
                cost: Some(1),
                unextractable: false,
            },
            Command::Constructor {
                span: span!(),
                name: sym.compose,
                schema: Schema {
                    input: vec![sym.mor, sym.mor],
                    output: sym.mor,
                },
                cost: Some(1),
                unextractable: false,
            },
            // Typing axioms for composites and identities.
            Command::AddRuleset(sym.axioms),
            Command::Rewrite(
                sym.axioms,
                Rewrite {
                    span: span!(),
                    lhs: self.dom(self.id(var!("x"))),
                    rhs: var!("x"),
                    conditions: vec![],
                },
                false,
            ),
            Command::Rewrite(
                sym.axioms,
                Rewrite {
                    span: span!(),
                    lhs: self.cod(self.id(var!("x"))),
                    rhs: var!("x"),
                    conditions: vec![],
                },
                false,
            ),
            Command::Rewrite(
                sym.axioms,
                Rewrite {
                    span: span!(),
                    lhs: self.dom(self.compose2(var!("f"), var!("g"))),
                    rhs: self.dom(var!("f")),
                    conditions: vec![],
                },
                false,
            ),
            Command::Rewrite(
                sym.axioms,
                Rewrite {
                    span: span!(),
                    lhs: self.cod(self.compose2(var!("f"), var!("g"))),
                    rhs: self.cod(var!("g")),
                    conditions: vec![],
                },
                false,
            ),
            // Associativity and unitality axioms, where associativity is a
            // bidirectional rewrite and unitality is unidirectional rewrites.
            Command::Rewrite(
                sym.axioms,
                Rewrite {
                    span: span!(),
                    lhs: self.compose2(self.compose2(var!("f"), var!("g")), var!("h")),
                    rhs: self.compose2(var!("f"), self.compose2(var!("g"), var!("h"))),
                    conditions: vec![],
                },
                false,
            ),
            Command::Rewrite(
                sym.axioms,
                Rewrite {
                    span: span!(),
                    lhs: self.compose2(var!("f"), self.compose2(var!("g"), var!("h"))),
                    rhs: self.compose2(self.compose2(var!("f"), var!("g")), var!("h")),
                    conditions: vec![],
                },
                false,
            ),
            Command::Rewrite(
                sym.axioms,
                Rewrite {
                    span: span!(),
                    lhs: self.compose2(var!("f"), self.id(var!("y"))),
                    rhs: var!("f"),
                    conditions: vec![], // Should we check cod(f) == y?
                },
                false,
            ),
            Command::Rewrite(
                sym.axioms,
                Rewrite {
                    span: span!(),
                    lhs: self.compose2(self.id(var!("x")), var!("f")),
                    rhs: var!("f"),
                    conditions: vec![], // Should we check dom(f) == x?
                },
                false,
            ),
        ]
    }
}

impl Default for CategoryProgramBuilder {
    fn default() -> Self {
        let mut result = Self {
            prog: vec![],
            sym: Default::default(),
        };
        result.preamble();
        result
    }
}

#[derive(Clone)]
struct CategorySymbols {
    ob: Symbol,
    mor: Symbol,
    ob_gen: Symbol,
    mor_gen: Symbol,
    dom: Symbol,
    cod: Symbol,
    id: Symbol,
    compose: Symbol,
    axioms: Symbol,
}

impl Default for CategorySymbols {
    fn default() -> Self {
        Self {
            ob: "Ob".into(),
            mor: "Mor".into(),
            ob_gen: "ObGen".into(),
            mor_gen: "MorGen".into(),
            dom: "dom".into(),
            cod: "cod".into(),
            id: "id".into(),
            compose: "compose".into(),
            axioms: "CatAxioms".into(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use expect_test::expect;
    use nonempty::nonempty;
    use ustr::ustr;

    #[test]
    fn sch_sgraph() {
        let mut sch_sgraph: UstrFpCategory = Default::default();
        let (v, e) = (ustr("V"), ustr("E"));
        let (s, t, i) = (ustr("src"), ustr("tgt"), ustr("inv"));
        sch_sgraph.add_ob_generators([v, e]);
        sch_sgraph.add_mor_generator(s, e, v);
        sch_sgraph.add_mor_generator(t, e, v);
        sch_sgraph.add_mor_generator(i, e, e);
        assert!(sch_sgraph.is_free());
        sch_sgraph.equate(Path::pair(i, i), Path::empty(e));
        sch_sgraph.equate(Path::pair(i, s), Path::single(t));
        sch_sgraph.equate(Path::pair(i, t), Path::single(s));
        assert!(!sch_sgraph.is_free());
        assert!(sch_sgraph.validate().is_ok());

        assert!(!sch_sgraph.morphisms_are_equal(Path::single(s), Path::single(t)));
        assert!(sch_sgraph.morphisms_are_equal(Path::pair(i, i), Path::empty(e)));
        assert!(sch_sgraph.morphisms_are_equal(Path::Seq(nonempty![i, i, i, s]), Path::single(t)));
    }

    #[test]
    fn egraph_preamble() {
        let prog = CategoryProgramBuilder::default().program();

        let expected = expect![[r#"
            (datatype Ob (ObGen String :cost 0))
            (datatype Mor (MorGen String :cost 0))
            (constructor dom (Mor) Ob :cost 1)
            (constructor cod (Mor) Ob :cost 1)
            (constructor id (Ob) Mor :cost 1)
            (constructor compose (Mor Mor) Mor :cost 1)
            (ruleset CatAxioms)
            (rewrite (dom (id x)) x :ruleset CatAxioms)
            (rewrite (cod (id x)) x :ruleset CatAxioms)
            (rewrite (dom (compose f g)) (dom f) :ruleset CatAxioms)
            (rewrite (cod (compose f g)) (cod g) :ruleset CatAxioms)
            (rewrite (compose (compose f g) h) (compose f (compose g h)) :ruleset CatAxioms)
            (rewrite (compose f (compose g h)) (compose (compose f g) h) :ruleset CatAxioms)
            (rewrite (compose f (id y)) f :ruleset CatAxioms)
            (rewrite (compose (id x) f) f :ruleset CatAxioms)
        "#]];
        expected.assert_eq(&prog.to_string());

        let mut egraph: EGraph = Default::default();
        assert!(prog.run_in(&mut egraph).is_ok());
    }
}
