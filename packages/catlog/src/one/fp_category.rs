/*! Finitely presented categories.

A *finitely presented category*, or *f.p. category* for short, is a [finite
graph](super::graph::FinGraph) together with a finite set of [path
equations](super::path::PathEq). This data defines a category whose objects are
the vertices of the graph and morphisms are paths in the graphs, regarded as
equivalent under the congruence relation generated by the path equations. For a
detailed description of this congruence relation, see ([Spivak
2014](crate::refs::CTForTheSciences), Definition 4.5.2.3).

In general, this congruence relation---the word problem for finitely presented
categories---cannot be decided, though in practice it often can be. The data
structure in this module uses [e-graphs](https://en.wikipedia.org/wiki/E-graph)
to check for equivalence of paths under the congruence.
 */

use std::cell::RefCell;
use std::collections::HashMap;
use std::fmt::Debug;
use std::hash::{BuildHasher, BuildHasherDefault, Hash, RandomState};

use derivative::Derivative;
use egglog::{EGraph, ast::*, span};
use nonempty::NonEmpty;
use ref_cast::RefCast;
use thiserror::Error;
use ustr::{IdentityHasher, Ustr};

use super::{category::*, graph::*, path::*};
use crate::egglog_util::{CommandRewrite, CommandRule, Program};
use crate::validate::{self, Validate};

/** A finitely presented category backed by an e-graph.

A data structure for a f.p. category in which the congruence relation generated
by the path equations is maintained by an e-graph. The question of whether paths
in the presented category are equivalent is referred to the e-graph.

# Interior mutability

Checking equivalence of paths requires mutating the underlying e-graph. However,
we do not want to regard this check as mutating, for the theoretical reason that
the check does not change the category presented and the practical reason that
it would cause mutable references to be aggressively propagated throughout the
codebase. Thus, we use the [interior
mutability](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html)
pattern to encapsulate the mutability of the e-graph and perform borrow checking
at runtime. The current implementation allows only *single-threaded* usage.
 */
#[derive(Clone, Derivative)]
#[derivative(Debug(bound = "V: Debug, E: Debug, S: Debug"))]
#[derivative(Default(bound = "S: Default", new = "true"))]
#[derivative(PartialEq(bound = "V: Eq + Hash, E: Eq + Hash, S: BuildHasher"))]
#[derivative(Eq(bound = "V: Eq + Hash, E: Eq + Hash, S: BuildHasher"))]
pub struct FpCategory<V, E, S = RandomState> {
    generators: HashGraph<V, E, S>,
    equations: Vec<PathEq<V, E>>,
    #[derivative(Debug = "ignore", PartialEq = "ignore")]
    builder: RefCell<CategoryProgramBuilder<V, E, S>>,
    #[derivative(Debug = "ignore", PartialEq = "ignore")]
    egraph: RefCell<EGraph>,
}

/// A finitely presented category with generators of type `Ustr`.
pub type UstrFpCategory = FpCategory<Ustr, Ustr, BuildHasherDefault<IdentityHasher>>;

impl<V, E, S> FpCategory<V, E, S>
where
    V: Eq + Clone + Hash,
    E: Eq + Clone + Hash,
    S: BuildHasher,
{
    /// Gets the generating graph of the category presentation.
    pub fn generators(&self) -> &(impl FinGraph<V = V, E = E> + use<V, E, S>) {
        &self.generators
    }

    /// Gets the path equations of the category presentation.
    pub fn equations(&self) -> impl Iterator<Item = &PathEq<V, E>> {
        self.equations.iter()
    }

    /// Is the category freely generated?
    pub fn is_free(&self) -> bool {
        self.equations.is_empty()
    }

    /// Adds an object generator.
    pub fn add_ob_generator(&mut self, v: V) {
        assert!(self.generators.add_vertex(v.clone()), "Object generator already exists");
        self.builder.get_mut().add_ob_generator(v);
    }

    /// Adds several object generators at once.
    pub fn add_ob_generators(&mut self, iter: impl IntoIterator<Item = V>) {
        for v in iter {
            self.add_ob_generator(v)
        }
    }

    /// Adds a morphism generator.
    pub fn add_mor_generator(&mut self, e: E, dom: V, cod: V) {
        assert!(
            self.generators.add_edge(e.clone(), dom.clone(), cod.clone()),
            "Morphism generator already exists"
        );
        let (dom, cod) = (self.ob_generator_expr(dom), self.ob_generator_expr(cod));
        self.builder.get_mut().add_mor_generator(e, dom, cod);
    }

    /// Adds a morphism generator without declaring its (co)domain.
    pub fn make_mor_generator(&mut self, e: E) {
        assert!(self.generators.make_edge(e.clone()), "Morphism generator already exists");
        self.builder.get_mut().make_mor_generator(e);
    }

    /// Gets the domain of a morphism generator.
    pub fn get_dom(&self, e: &E) -> Option<&V> {
        self.generators.get_src(e)
    }

    /// Gets the codomain of a morphism generator.
    pub fn get_cod(&self, e: &E) -> Option<&V> {
        self.generators.get_tgt(e)
    }

    /// Sets the domain of a morphism generator.
    pub fn set_dom(&mut self, e: E, v: V) {
        assert!(
            self.generators.set_src(e.clone(), v.clone()).is_none(),
            "Domain of morphism generator should not already be set"
        );
        let (mor, ob) = (self.mor_generator_expr(e), self.ob_generator_expr(v));
        self.builder.get_mut().set_dom(mor, ob);
    }

    /// Sets the codomain of a morphism generator.
    pub fn set_cod(&mut self, e: E, v: V) {
        assert!(
            self.generators.set_tgt(e.clone(), v.clone()).is_none(),
            "Codomain of morphism generator should not already be set"
        );
        let (mor, ob) = (self.mor_generator_expr(e), self.ob_generator_expr(v));
        self.builder.get_mut().set_cod(mor, ob);
    }

    /// Adds a path equation to the presentation.
    pub fn add_equation(&mut self, eq: PathEq<V, E>) {
        self.equations.push(eq.clone());
        let (lhs, rhs) = (self.path_expr(eq.lhs), self.path_expr(eq.rhs));
        self.builder.get_mut().equate(lhs, rhs);
    }

    /// Equates two path in the presentation.
    pub fn equate(&mut self, lhs: Path<V, E>, rhs: Path<V, E>) {
        self.add_equation(PathEq::new(lhs, rhs));
    }

    fn ob_generator_expr(&self, v: V) -> Expr {
        self.builder.borrow_mut().ob_generator(v)
    }
    fn mor_generator_expr(&self, e: E) -> Expr {
        self.builder.borrow_mut().mor_generator(e)
    }
    fn path_expr(&self, path: Path<V, E>) -> Expr {
        path.map_reduce(
            |v| {
                let ob = self.ob_generator_expr(v);
                self.builder.borrow().id(ob)
            },
            |e| self.mor_generator_expr(e),
            |f, g| self.builder.borrow().compose2(f, g),
        )
    }

    /// Iterates over failures to be a well-defined presentation of a category.
    pub fn iter_invalid(&self) -> impl Iterator<Item = InvalidFpCategory<E>> + '_ {
        let generator_errors = self.generators.iter_invalid().map(|err| match err {
            InvalidGraph::Src(e) => InvalidFpCategory::Dom(e),
            InvalidGraph::Tgt(e) => InvalidFpCategory::Cod(e),
        });
        let equation_errors = self.equations.iter().enumerate().flat_map(|(i, eq)| {
            eq.iter_invalid_in(&self.generators).map(move |err| match err {
                InvalidPathEq::Lhs() => InvalidFpCategory::EqLhs(i),
                InvalidPathEq::Rhs() => InvalidFpCategory::EqRhs(i),
                InvalidPathEq::Src() => InvalidFpCategory::EqSrc(i),
                InvalidPathEq::Tgt() => InvalidFpCategory::EqTgt(i),
            })
        });
        generator_errors.chain(equation_errors)
    }
}

impl<V, E, S> Category for FpCategory<V, E, S>
where
    V: Eq + Clone + Hash,
    E: Eq + Clone + Hash,
    S: BuildHasher,
{
    type Ob = V;
    type Mor = Path<V, E>;

    fn has_ob(&self, x: &Self::Ob) -> bool {
        self.generators.has_vertex(x)
    }
    fn has_mor(&self, path: &Self::Mor) -> bool {
        path.contained_in(&self.generators)
    }
    fn dom(&self, path: &Self::Mor) -> Self::Ob {
        path.src(&self.generators)
    }
    fn cod(&self, path: &Self::Mor) -> Self::Ob {
        path.tgt(&self.generators)
    }

    fn compose(&self, path: Path<Self::Ob, Self::Mor>) -> Self::Mor {
        path.flatten_in(&self.generators).expect("Paths should be composable")
    }
    fn compose2(&self, path1: Self::Mor, path2: Self::Mor) -> Self::Mor {
        path1
            .concat_in(&self.generators, path2)
            .expect("Target of first path should equal source of second path")
    }

    fn morphisms_are_equal(&self, path1: Self::Mor, path2: Self::Mor) -> bool {
        let (lhs, rhs) = (self.path_expr(path1), self.path_expr(path2));
        self.builder.borrow_mut().check_equal(lhs, rhs);
        self.builder
            .borrow_mut()
            .program()
            .check_in(&mut self.egraph.borrow_mut())
            .expect("Unexpected egglog error")
    }
}

impl<V, E, S> FgCategory for FpCategory<V, E, S>
where
    V: Eq + Clone + Hash,
    E: Eq + Clone + Hash,
    S: BuildHasher,
{
    type ObGen = V;
    type MorGen = E;

    fn ob_generators(&self) -> impl Iterator<Item = Self::ObGen> {
        self.generators.vertices()
    }
    fn mor_generators(&self) -> impl Iterator<Item = Self::MorGen> {
        self.generators.edges()
    }
    fn mor_generator_dom(&self, f: &Self::MorGen) -> Self::Ob {
        self.generators.src(f)
    }
    fn mor_generator_cod(&self, f: &Self::MorGen) -> Self::Ob {
        self.generators.tgt(f)
    }
}

impl<V, E, S> Validate for FpCategory<V, E, S>
where
    V: Eq + Clone + Hash,
    E: Eq + Clone + Hash,
    S: BuildHasher,
{
    type ValidationError = InvalidFpCategory<E>;

    fn validate(&self) -> Result<(), NonEmpty<Self::ValidationError>> {
        validate::wrap_errors(self.iter_invalid())
    }
}

/// A failure of a finite presentation of a category to be well defined.
#[derive(Debug, Error)]
pub enum InvalidFpCategory<E> {
    /// Morphism generator assigned a domain not contained in the category.
    #[error("Domain of morphism generator `{0}` is not in the category")]
    Dom(E),

    /// Morphism generator assigned a codomain not contained in the category.
    #[error("Codomain of morphism generator `{0}` is not in the category")]
    Cod(E),

    /// Path in left hand side of equation not contained in the category.
    #[error("LHS of path equation `{0}` is not in the category")]
    EqLhs(usize),

    /// Path in right hand side of equation not contained in the category.
    #[error("RHS of path equation `{0}` is not in the category")]
    EqRhs(usize),

    /// Sources of left and right hand sides of path equation are not equal.
    #[error("Path equation `{0}` has sources that are not equal")]
    EqSrc(usize),

    /// Targets of left and right hand sides of path equation are not equal.
    #[error("Path equation `{0}` has targets that are not equal")]
    EqTgt(usize),
}

/** Program builder for computing with categories in egglog.

Maintains an egglog [`Program`] as well as mappings from vertices and edges in
the category's generating graph to numeric IDs for generator terms in egglog. We
do not assume that vertices or edges can be converted to strings/symbols since
we want to support hierarchical naming, where names are a list of symbols.
 */
#[derive(Clone)]
struct CategoryProgramBuilder<V, E, S = RandomState> {
    prog: Vec<Command>,
    sym: CategorySymbols,
    ob_generators: HashMap<V, usize, S>,
    mor_generators: HashMap<E, usize, S>,
}

impl<V, E, S> CategoryProgramBuilder<V, E, S>
where
    V: Eq + Hash,
    E: Eq + Hash,
    S: BuildHasher,
{
    /// Declares an object generator.
    pub fn add_ob_generator(&mut self, v: V) -> usize {
        let id = self.ob_generator_id(v);
        let action = Action::Expr(span!(), self.ob_generator_with_id(id));
        self.prog.push(Command::Action(action));
        id
    }

    /// Declares a morphism generator and sets its domain and codmain.
    pub fn add_mor_generator(&mut self, e: E, dom: Expr, cod: Expr) -> usize {
        let id = self.make_mor_generator(e);
        self.set_dom(self.mor_generator_with_id(id), dom);
        self.set_cod(self.mor_generator_with_id(id), cod);
        id
    }

    /// Declares a morphism generator.
    pub fn make_mor_generator(&mut self, e: E) -> usize {
        let id = self.mor_generator_id(e);
        let action = Action::Expr(span!(), self.mor_generator_with_id(id));
        self.prog.push(Command::Action(action));
        id
    }

    /// Sets the domain of a morphism.
    pub fn set_dom(&mut self, mor: Expr, ob: Expr) {
        let dom = self.dom(mor);
        Program::ref_cast_mut(&mut self.prog).union(dom, ob);
    }

    /// Sets the codomain of a morphism.
    pub fn set_cod(&mut self, mor: Expr, ob: Expr) {
        let cod = self.cod(mor);
        Program::ref_cast_mut(&mut self.prog).union(cod, ob);
    }

    /// Constructs an object generator expression for the given vertex.
    pub fn ob_generator(&mut self, v: V) -> Expr {
        let id = self.ob_generator_id(v);
        self.ob_generator_with_id(id)
    }

    /// Gets or creates the internal ID for a given vertex.
    pub fn ob_generator_id(&mut self, v: V) -> usize {
        let n = self.ob_generators.len();
        *self.ob_generators.entry(v).or_insert(n)
    }

    /// Constructs a morphism generator expression for the given edge.
    pub fn mor_generator(&mut self, e: E) -> Expr {
        let id = self.mor_generator_id(e);
        self.mor_generator_with_id(id)
    }

    /// Gets or creates the internal ID for a given edge.
    pub fn mor_generator_id(&mut self, e: E) -> usize {
        let n = self.mor_generators.len();
        *self.mor_generators.entry(e).or_insert(n)
    }
}

impl<V, E, S> CategoryProgramBuilder<V, E, S> {
    /// Extracts the egglog program, consuming the cached statements.
    pub fn program(&mut self) -> Program {
        Program(std::mem::take(&mut self.prog))
    }

    /// Constructs an object generator call for the given internal ID.
    fn ob_generator_with_id(&self, id: usize) -> Expr {
        let id: i64 = id.try_into().expect("Shouldn't have too many object generators");
        call!(self.sym.ob_gen, vec![lit!(id)])
    }

    /// Constructs a morphism generator call for the given internal ID.
    fn mor_generator_with_id(&self, id: usize) -> Expr {
        let id: i64 = id.try_into().expect("Shouldn't have too many morphism generators");
        call!(self.sym.mor_gen, vec![lit!(id)])
    }

    /// Constructs a call of the morphism-is-valid predicate.
    pub fn mor_is_valid(&self, mor: Expr) -> Expr {
        call!(self.sym.mor_is_valid, vec![mor])
    }

    /// Constructs a domain call.
    pub fn dom(&self, mor: Expr) -> Expr {
        call!(self.sym.dom, vec![mor])
    }

    /// Constructs a codomain call.
    pub fn cod(&self, mor: Expr) -> Expr {
        call!(self.sym.cod, vec![mor])
    }

    /// Constructs an identity call.
    pub fn id(&self, ob: Expr) -> Expr {
        call!(self.sym.id, vec![ob])
    }

    /// Constructs a binary composition call.
    pub fn compose2(&self, f: Expr, g: Expr) -> Expr {
        call!(self.sym.compose, vec![f, g])
    }

    /// Equates two expressions in the category.
    pub fn equate(&mut self, lhs: Expr, rhs: Expr) {
        Program::ref_cast_mut(&mut self.prog).union(lhs, rhs);
    }

    /// Checks whether the expressions are equal.
    pub fn check_equal(&mut self, lhs: Expr, rhs: Expr) {
        let schedule = self.schedule();
        Program::ref_cast_mut(&mut self.prog).check_equal(lhs, rhs, Some(schedule));
    }

    /// Constructs a schedule to saturate the category axioms.
    fn schedule(&self) -> Schedule {
        Schedule::Saturate(
            span!(),
            Box::new(Schedule::Run(
                span!(),
                GenericRunConfig {
                    ruleset: self.sym.axioms,
                    until: None,
                },
            )),
        )
    }

    /// Generates the preamble for the program.
    fn preamble(&mut self) {
        let sym = &self.sym;
        self.prog = vec![
            // Types: objects and morphisms.
            Command::Datatype {
                span: span!(),
                name: sym.ob,
                variants: vec![Variant {
                    span: span!(),
                    name: sym.ob_gen,
                    types: vec!["i64".into()],
                    cost: Some(0),
                }],
            },
            Command::Datatype {
                span: span!(),
                name: sym.mor,
                variants: vec![Variant {
                    span: span!(),
                    name: sym.mor_gen,
                    types: vec!["i64".into()],
                    cost: Some(0),
                }],
            },
            // Constructors: (co)domain, identity, composition.
            Command::Constructor {
                span: span!(),
                name: sym.dom,
                schema: Schema {
                    input: vec![sym.mor],
                    output: sym.ob,
                },
                cost: Some(1),
                unextractable: false,
            },
            Command::Constructor {
                span: span!(),
                name: sym.cod,
                schema: Schema {
                    input: vec![sym.mor],
                    output: sym.ob,
                },
                cost: Some(1),
                unextractable: false,
            },
            Command::Constructor {
                span: span!(),
                name: sym.id,
                schema: Schema {
                    input: vec![sym.ob],
                    output: sym.mor,
                },
                cost: Some(1),
                unextractable: false,
            },
            Command::Constructor {
                span: span!(),
                name: sym.compose,
                schema: Schema {
                    input: vec![sym.mor, sym.mor],
                    output: sym.mor,
                },
                cost: Some(1),
                unextractable: false,
            },
            // Rule set: all the axioms for a category.
            Command::AddRuleset(sym.axioms),
            // Predicate: is the morphism well-typed?
            Command::Relation {
                span: span!(),
                name: sym.mor_is_valid,
                inputs: vec![sym.mor],
            },
            // Rule: every morphism generator is well-typed.
            Command::from(CommandRule {
                ruleset: sym.axioms,
                head: vec![Action::Expr(span!(), self.mor_is_valid(var!("f")))],
                body: vec![Fact::Eq(span!(), var!("f"), call!(sym.mor_gen, vec![var!("name")]))],
            }),
            // Rule: every identity morphism is well-typed.
            Command::from(CommandRule {
                ruleset: sym.axioms,
                head: vec![Action::Expr(span!(), self.mor_is_valid(var!("f")))],
                body: vec![Fact::Eq(span!(), var!("f"), self.id(var!("x")))],
            }),
            // Rule: a composite of two morphisms is well-typed if both
            // morphisms are well-typed and their (co)domains are compatible.
            Command::from(CommandRule {
                ruleset: sym.axioms,
                head: vec![Action::Expr(span!(), self.mor_is_valid(var!("fg")))],
                body: vec![
                    Fact::Eq(span!(), var!("fg"), self.compose2(var!("f"), var!("g"))),
                    Fact::Fact(self.mor_is_valid(var!("f"))),
                    Fact::Fact(self.mor_is_valid(var!("g"))),
                    Fact::Eq(span!(), self.cod(var!("f")), self.dom(var!("g"))),
                ],
            }),
            // Rules: (co)domains of composites and identities.
            Command::from(CommandRule {
                ruleset: sym.axioms,
                head: vec![
                    Action::Union(span!(), self.dom(var!("fg")), self.dom(var!("f"))),
                    Action::Union(span!(), self.cod(var!("fg")), self.cod(var!("g"))),
                ],
                body: vec![
                    Fact::Eq(span!(), var!("fg"), self.compose2(var!("f"), var!("g"))),
                    Fact::Fact(self.mor_is_valid(var!("fg"))),
                ],
            }),
            Command::from(CommandRewrite {
                ruleset: sym.axioms,
                lhs: self.dom(self.id(var!("x"))),
                rhs: var!("x"),
            }),
            Command::from(CommandRewrite {
                ruleset: sym.axioms,
                lhs: self.cod(self.id(var!("x"))),
                rhs: var!("x"),
            }),
            // Associativity and unitality axioms, where associativity is a
            // bidirectional rewrite and unitality is unidirectional rewrites.
            Command::from(CommandRule {
                ruleset: sym.axioms,
                head: vec![Action::Union(
                    span!(),
                    var!("fgh"),
                    self.compose2(var!("f"), self.compose2(var!("g"), var!("h"))),
                )],
                body: vec![
                    Fact::Eq(
                        span!(),
                        var!("fgh"),
                        self.compose2(self.compose2(var!("f"), var!("g")), var!("h")),
                    ),
                    Fact::Fact(self.mor_is_valid(var!("fgh"))),
                ],
            }),
            Command::from(CommandRule {
                ruleset: sym.axioms,
                head: vec![Action::Union(
                    span!(),
                    var!("fgh"),
                    self.compose2(self.compose2(var!("f"), var!("g")), var!("h")),
                )],
                body: vec![
                    Fact::Eq(
                        span!(),
                        var!("fgh"),
                        self.compose2(var!("f"), self.compose2(var!("g"), var!("h"))),
                    ),
                    Fact::Fact(self.mor_is_valid(var!("fgh"))),
                ],
            }),
            Command::from(CommandRewrite {
                ruleset: sym.axioms,
                lhs: self.compose2(var!("f"), self.id(self.cod(var!("f")))),
                rhs: var!("f"),
            }),
            Command::from(CommandRewrite {
                ruleset: sym.axioms,
                lhs: self.compose2(self.id(self.dom(var!("f"))), var!("f")),
                rhs: var!("f"),
            }),
        ]
    }
}

impl<V, E, S: Default> Default for CategoryProgramBuilder<V, E, S> {
    fn default() -> Self {
        let mut result = Self {
            prog: Default::default(),
            sym: Default::default(),
            ob_generators: Default::default(),
            mor_generators: Default::default(),
        };
        result.preamble();
        result
    }
}

#[derive(Clone)]
struct CategorySymbols {
    ob: Symbol,
    mor: Symbol,
    mor_is_valid: Symbol,
    ob_gen: Symbol,
    mor_gen: Symbol,
    dom: Symbol,
    cod: Symbol,
    id: Symbol,
    compose: Symbol,
    axioms: Symbol,
}

impl Default for CategorySymbols {
    fn default() -> Self {
        Self {
            ob: "Ob".into(),
            mor: "Mor".into(),
            mor_is_valid: "is_mor_valid".into(),
            ob_gen: "ObGen".into(),
            mor_gen: "MorGen".into(),
            dom: "dom".into(),
            cod: "cod".into(),
            id: "id".into(),
            compose: "compose".into(),
            axioms: "CatAxioms".into(),
        }
    }
}

#[cfg(test)]
use ustr::ustr;

/// The schema for graphs, an f.p. category.
#[cfg(test)]
pub fn sch_graph() -> UstrFpCategory {
    let mut cat = UstrFpCategory::new();
    let (v, e) = (ustr("V"), ustr("E"));
    cat.add_ob_generators([v, e]);
    cat.add_mor_generator(ustr("src"), e, v);
    cat.add_mor_generator(ustr("tgt"), e, v);
    cat
}

/// The schema for symmetric graphs, an f.p. category.
#[cfg(test)]
pub fn sch_sgraph() -> UstrFpCategory {
    let mut cat = UstrFpCategory::new();
    let (v, e) = (ustr("V"), ustr("E"));
    let (s, t, i) = (ustr("src"), ustr("tgt"), ustr("inv"));
    cat.add_ob_generators([v, e]);
    cat.add_mor_generator(s, e, v);
    cat.add_mor_generator(t, e, v);
    cat.add_mor_generator(i, e, e);
    cat.equate(Path::pair(i, i), Path::empty(e));
    cat.equate(Path::pair(i, s), Path::single(t));
    cat.equate(Path::pair(i, t), Path::single(s));
    cat
}

/// The schema for half-edge graphs, an f.p. category.
#[cfg(test)]
pub fn sch_hgraph() -> UstrFpCategory {
    let mut cat = UstrFpCategory::new();
    let (v, h) = (ustr("V"), ustr("H"));
    let (vert, inv) = (ustr("vert"), ustr("inv"));
    cat.add_ob_generators([v, h]);
    cat.add_mor_generator(vert, h, v);
    cat.add_mor_generator(inv, h, h);
    cat.equate(Path::pair(inv, inv), Path::empty(h));
    cat
}

#[cfg(test)]
mod tests {
    use super::*;
    use expect_test::expect;
    use nonempty::nonempty;
    use ustr::ustr;

    #[test]
    fn sch_sgraph_equations() {
        let sch_sgraph = sch_sgraph();
        assert!(!sch_sgraph.is_free());
        assert!(sch_sgraph.validate().is_ok());

        let (s, t, i) = (ustr("src"), ustr("tgt"), ustr("inv"));
        assert!(!sch_sgraph.morphisms_are_equal(Path::single(s), Path::single(t)));
        assert!(sch_sgraph.morphisms_are_equal(Path::pair(i, i), Path::empty(ustr("E"))));
        assert!(sch_sgraph.morphisms_are_equal(Path::Seq(nonempty![i, i, i, s]), Path::single(t)));
    }

    #[test]
    fn egraph_preamble() {
        let mut builder: CategoryProgramBuilder<char, char, RandomState> = Default::default();
        let prog = builder.program();

        let expected = expect![[r#"
            (datatype Ob (ObGen i64 :cost 0))
            (datatype Mor (MorGen i64 :cost 0))
            (constructor dom (Mor) Ob :cost 1)
            (constructor cod (Mor) Ob :cost 1)
            (constructor id (Ob) Mor :cost 1)
            (constructor compose (Mor Mor) Mor :cost 1)
            (ruleset CatAxioms)
            (relation is_mor_valid (Mor))
            (rule ((= f (MorGen name)))
                  ((is_mor_valid f))
                    :ruleset CatAxioms )
            (rule ((= f (id x)))
                  ((is_mor_valid f))
                    :ruleset CatAxioms )
            (rule ((= fg (compose f g))
                   (is_mor_valid f)
                   (is_mor_valid g)
                   (= (cod f) (dom g)))
                  ((is_mor_valid fg))
                    :ruleset CatAxioms )
            (rule ((= fg (compose f g))
                   (is_mor_valid fg))
                  ((union (dom fg) (dom f))
                   (union (cod fg) (cod g)))
                    :ruleset CatAxioms )
            (rewrite (dom (id x)) x :ruleset CatAxioms)
            (rewrite (cod (id x)) x :ruleset CatAxioms)
            (rule ((= fgh (compose (compose f g) h))
                   (is_mor_valid fgh))
                  ((union fgh (compose f (compose g h))))
                    :ruleset CatAxioms )
            (rule ((= fgh (compose f (compose g h)))
                   (is_mor_valid fgh))
                  ((union fgh (compose (compose f g) h)))
                    :ruleset CatAxioms )
            (rewrite (compose f (id (cod f))) f :ruleset CatAxioms)
            (rewrite (compose (id (dom f)) f) f :ruleset CatAxioms)
        "#]];
        expected.assert_eq(&prog.to_string());

        let mut egraph: EGraph = Default::default();
        assert!(prog.run_in(&mut egraph).is_ok());
    }
}
