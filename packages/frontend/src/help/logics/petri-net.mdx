import { A } from "@solidjs/router";
import { HelpAnalysisById } from "../logic_help_detail"

## Description

**Petri nets** were invented to express discrete-event dynamical systems with concurrency, or networks of resources and processes, describing how various states (called **places**) relate to one another in terms of **transitions**.
Each transition has incoming and outgoing arrows (called **arcs**) connected to places, which describe the **input** and **output** places of the transition (respectively).

One way of understanding Petri nets is through their **token semantics**.
We place a number of "tokens" in each place and then check all the transitions to see if all their input places have a token: if so, then we can "fire" the transition, moving the tokens from the input places to the output places; if not, then nothing happens.
In many classical references the token semantics are built directly in to the definition of Petri nets (often called a **marking** or **tokening**), but an unmarked Petri net is already itself a useful formal gadget, analogous to how can be useful to consider an ordinary differential equation without giving its initial conditions.


### Further reading

- Wikipedia: [Petri net](https://en.wikipedia.org/wiki/Petri_net)
- John C. Baez, Blake S. Pollard, "A Compositional Framework for Reaction Networks", (2017) [arXiv:1704.02051](https://arxiv.org/abs/1704.02051)
- Series of blog posts by John Baez on Petri nets, all listed
  [here](https://johncarlosbaez.wordpress.com/?s=petri)


## Instances and analyses

### Analyses

<HelpAnalysisById theory={props.theory} analysisId="diagram"/>

<HelpAnalysisById theory={props.theory} analysisId="subreachability">
A **tokening** of a Petri net assigns some number of tokens to each place. A transition can **fire** by removing a token from each of its inputs and adding a token to each of its outputs. Given an initial tokening, we are concerned with all of the possible tokenings that can be arrived at via some sequence of transitions firing. This is usually infinite. Sometimes we care about a particular tokening as "forbidden": we care about confirming that no sequence of transitions firing could ever reach state for which includes the forbidden state.

This analysis shows a ❌ if there does exist any reachable tokening from the given initial one which is greater or equal to the given forbidden one, and shows a ✅ otherwise.

*Note:* we are *not* checking that the forbidden state is reached exactly, just whether *some* state which is strictly larger than the forbidden state can be reached.
</HelpAnalysisById>

<HelpAnalysisById theory={props.theory} analysisId="mass-action">
Places are interpreted as quantities that can vary in time ("concentrations"), and the transitions ("reactions") in the model determine equations constraining the time derivatives of the stocks.
Each place is given an **initial value**.

- A transition $A\xrightarrow{T}B$ between places $A$ and $B$ is interpreted as the equations $\{\dot{A}=-T,\dot{B}=T\}$, i.e. the transition $T$ goes out of $A$ and into $B$.

- Equations governing places add linearly: in an arbitrary Petri net, the equation governing a place $A$ is $\dot{A}=\sum_{A_\text{in}}T_i - \sum_{A_\text{out}}T_j$, where $A_\text{in}$ (resp. $A_\text{out}$) is the set of all transitions whose target (resp. source) is $A$.

- Transitions are determined by their **rate** coefficient $r$ and take into account only *incoming* arcs: a transition $A\xrightarrow{T}B$ imposes the equation $T=rA$.
However, equations governing transitions are *non-linear*: if a transition $T$ has two incoming arcs from places $A$ and $A'$, then $T=rAA'$.
</HelpAnalysisById>

<HelpAnalysisById theory={props.theory} analysisId="stochastic-mass-action">
In a stochastic Petri net (SPN), the input (output) arcs of each transition consume (produce) integer numbers of tokens at their respective places. Each transition has a clock, a random variable giving the next time it would fire, if it were the next one to fire. When all the clocks are Exponential random variates, it is the stochastic analogue of the ordinary differential equation interpretation. The mass-action nets here consider the rate parameter of each Exponential clock to be the product of the reactants, potentially multiplied by a reaction constant. The Gillespie method is one way to sample a trajectory from an SPN, which uses the fact that the sum of Exponential distributions is also an Exponential distribution, to first sample the next time any transition fires, and then samples the particular one which fired with probability proportional to the rate parameter of each transition.

Let's consider the simple SIR model as an example:

$[\mathrm{S}, \mathrm{I}]\xrightarrow{\text{infection}}[\mathrm{I},\mathrm{I}]$

$[\mathrm{I}]\xrightarrow{\text{recovery}}[\mathrm{R}]$

The infection rate is proportional to the product of the sizes between susceptible and infected populations, and the recovery rate is proportional to the infected populations. In our example, if infection takes place, the susceptible population decreases by one and the infected increases by one, since an infected person was "used" to produce two new infected persons. If a recovery takes place, then the infected and recovery populations decrease and increase by one, respectively.

We can add an additional `death` process by either considering a new population "D" for "deceased," or by leaving the list in the domain empty:

$[\mathrm{I}]\xrightarrow{\text{death}}[\phantom{I}]$

In this case, a death is interpreted as only decrementing the infected population. The empty list (a valid term in the model) has a valid interpretation in the analysis.

We use the Gillespie algorithm implemented in the [`Armavica/rebop`](https://github.com/Armavica/rebop) package. This process was first popularized by Gillespie in ["A General Method for Numerically Simulating the Stochastic Time Evolution of Coupled Chemical Reactions"](https://doi.org/10.1016/0021-9991(76)90041-3).
</HelpAnalysisById>
