\title{Rules of DoubleTT}
\import{macros}

\subtree{
\title{Contexts}

\ul{

  \li{\em{Empty context}:

  \prooftree{
  \infer0{\vdash \cdot\ \context}
  }
  }

  \li{\em{Context extension}:

  \prooftree{
  \hypo{\vdash \Gamma\ \context}
  \hypo{\Gamma \vdash A\ \type}
  \infer2{\vdash \Gamma, u: A\ \context}
  }
  }

}

\subtree{
  \title{Variables}
  \taxon{notation}

  \p{In a departure from standard type-theoretic notation, we use the letters
  #{u, v, \dots} for variables and the letters #{x, y, \dots} for arbitrary
  terms of object types.}

}
}

\subtree{
\title{Object types}

\ul{

  \li{\em{Object type former}: For each object in the double theory, there is an
  object type:

  \prooftree{
  \hypo{\dbl{T} \vDash X\ \ob}
  \hypo{\vdash \Gamma\ \context}
  \infer2{\vdash \Ob_X\ \type}
  }
  }

  \li{\em{Functor application}:

  \prooftree{
  \hypo{\dbl{T} \vDash (F: X \to Y)}
  \hypo{\Gamma \vdash x: \Ob_X}
  \infer2{\Gamma \vdash F(x): \Ob_Y}
  }
  }

}
}

\subtree{
\title{Hom types}

\ul{
  
  \li{\em{Hom type former}: For each object in the double theory, there is a
  family of Hom types, parameterized by pairs of object terms:

  \prooftree{
  \hypo{\dbl{T} \vDash X\ \ob}
  \hypo{\Gamma \vdash x: \Ob_X}
  \hypo{\Gamma \vdash x': \Ob_X}
  \infer3{\Gamma \vdash \Hom_X(x,x')\ \type}
  }
  }

  \li{\em{Functor application}:

  \prooftree{
  \hypo{\dbl{T} \vDash (F: X \to Y)}
  \hypo{\Gamma \vdash x: \Ob_X}
  \hypo{\Gamma \vdash x': \Ob_X}
  \hypo{\Gamma \vdash f: \Hom_X(x,x')}
  \infer4{\Gamma \vdash F(f): \Hom_Y(F(x), F(x'))}
  }
  }

  \li{\em{Identity}:

  \prooftree{
  \hypo{\dbl{T} \vDash X\ \ob}
  \hypo{\Gamma \vdash x: \Ob_X}
  \infer2{\Gamma \vdash 1_x: \Hom_X(x,x)}
  }
  }

  \li{\em{Composition}:

  \prooftree{
  \hypo{\dbl{T} \vDash X\ \ob}
  \hypo{\Gamma \vdash x,x',x'': \Ob_X}
  \hypo{\Gamma \vdash f: \Hom_X(x,x')}
  \hypo{\Gamma \vdash g: \Hom_X(x',x'')}
  \infer4{\Gamma \vdash f \cdot g: \Hom_X(x,x'')}
  }
  }

}
}

\subtree{
\title{Morphism types}

\ul{

  \li{\em{Morphism type former}: For each proarrow in the double theory, there
  is a family of morphism types, parameterized by pairs of object terms:

  \prooftree{
  \hypo{\dbl{T} \vDash (P: X \proto Y)}
  \hypo{\Gamma \vdash x: X}
  \hypo{\Gamma \vdash y: Y}
  \infer3{\Gamma \vdash P(x,y)\ \type}
  }
  }

  \li{\em{Pre-composition}:

  \prooftree{
  \hypo{\dbl{T} \vDash (P: X \proto Y)}
  \hypo{\Gamma \vdash x, x': \Ob_X}
  \hypo{\Gamma \vdash y: \Ob_Y}
  \hypo{\Gamma \vdash p: P(x,y)}
  \hypo{\Gamma \vdash f: \Hom_X(x',x)}
  \infer5{\Gamma \vdash f \cdot p: P(x',y)}
  }
  }

  \li{\em{Post-composition}:

  \prooftree{
  \hypo{\dbl{T} \vDash (P: X \proto Y)}
  \hypo{\Gamma \vdash x: \Ob_X}
  \hypo{\Gamma \vdash y, y': \Ob_Y}
  \hypo{\Gamma \vdash p: P(x,y)}
  \hypo{\Gamma \vdash g: \Hom_Y(y,y')}
  \infer5{\Gamma \vdash p \cdot g: P(x,y')}
  }
  }

}
}

\subtree{
\title{Unit type}

\ul{

  \li{\em{Unit type former}:

  \prooftree{
  \hypo{\Gamma\ \context}
  \infer1{\Gamma: 1\ \type}
  }
  }

  \li{\em{Unit introduction}:

  \prooftree{
  \hypo{\Gamma\ \context}
  \infer1{\Gamma \vdash *: 1}
  }
  }

  \li{\em{Uniqueness rule}:

  \prooftree{
  \hypo{\Gamma \vdash x: 1}
  \infer1{\Gamma \vdash x = *: 1}
  }
  }

}
}

\subtree{
\title{Empty type}

\ul{

  \li{\em{Empty type former}:

  \prooftree{
  \hypo{\Gamma\ \context}
  \infer1{\Gamma: 0\ \type}
  }
  }

  \li{\em{Empty elimination}:

  \prooftree{
  \hypo{\Gamma \vdash a: 0}
  \hypo{\Gamma, v: 0 \vdash A\ \type}
  \infer2{\Gamma \vdash \ind_0(a): A[a/v]}
  }
  }

}

\subtree{
  \title{Uniqueness rules for inductive types}
  \taxon{Remark}

  \p{

  We follow convention in omitting the \em{uniqueness} rules (#{\eta} rules) for
  inductive types ([Angiuli & Gratzer](principles-dtt), Section 2.5.5). In the
  case of the empty type, this rule would be:

  \prooftree{
  \hypo{\Gamma \vdash b: 0}
  \hypo{\Gamma, v: 0 \vdash a: A}
  \infer2{\Gamma \vdash \ind_0(b) = a[b/v]: A[b/v]}
  }

  }
}
}

\subtree{
\title{Codiscrete modality}

\p{The codiscrete modality is an idempotent monad #{(\dbl{T}, \coDisc, \eta)} on
the double theory.}

\ul{

  \li{Computation rules for object types:

  \p{\centerfigs{
  \prooftreeinline{
  \hypo{\dbl{T} \vDash X\ \ob}
  \hypo{\vdash \Gamma\ \context}
  \infer2{\Gamma \vdash \Ob_{\coDisc(X)} = \Ob_X\ \type}
  }
  #{\qquad\qquad}
  \prooftreeinline{
  \hypo{\dbl{T} \vDash X\ \ob}
  \hypo{\Gamma \vdash x: \Ob_X}
  \infer2{\Gamma \vdash \eta_X(x) = x: \Ob_X}
  }
  }}
  \prooftree{
  \hypo{\dbl{T} \vDash (F: X \to Y)}
  \hypo{\Gamma \vdash x: \Ob_X}
  \infer2{\Gamma \vdash (\coDisc F)(x) = F(x) : \Ob_Y}
  }
  }

  \li{Computation rules for Hom types:

  \prooftree{
  \hypo{\dbl{T} \vDash X\ \ob}
  \hypo{\Gamma \vdash x, x': \Ob_X}
  \infer2{\Gamma \vdash \Hom_{\coDisc(X)}(x,x') = 1\ \type}
  }
  \prooftree{
  \hypo{\dbl{T} \vDash X\ \ob}
  \hypo{\Gamma \vdash x, x': \Ob_X}
  \hypo{\Gamma \vdash f: \Hom_X(x,x')}
  \infer[dashed]3{\Gamma \vdash \eta_X(f) = *: 1}
  }
  \prooftree{
  \hypo{\dbl{T} \vdash (F: X \to Y)}
  \hypo{\Gamma \vdash x, x': \Ob_X}
  \hypo{\Gamma \vdash f: \Hom_X(x,x')}
  \infer[dashed]3{\Gamma \vdash (\coDisc F)(f) = *: 1}
  }

  Note that the first judgment makes the other two judgments admissable.
  }

  \li{Computation rules for morphism types:

  \prooftree{
  \hypo{\dbl{T} \vDash (P: X \proto Y)}
  \hypo{\Gamma \vdash x: \Ob_X}
  \hypo{\Gamma \vdash y: \Ob_Y}
  \infer3{\Gamma \vdash (\coDisc P)(x,y) = 1\ \type}
  }
  \prooftree{
  \hypo{\dbl{T} \vDash (P: X \proto Y)}
  \hypo{\Gamma \vdash x: \Ob_X}
  \hypo{\Gamma \vdash y: \Ob_Y}
  \hypo{\Gamma \vdash p: P(x, y)}
  \infer[dashed]4{\Gamma \vdash \eta_P(p) = *: 1}
  }

  \strong{TODO}: Admissable rule for cell applications
  }

}
}

\subtree{
\title{Discrete modality}

\p{The discrete modality is an idempotent comonad #{(\dbl{T}, \Disc, \varepsilon)} on
the double theory.}

\ul{

  \li{Computation rules for object types:

  \p{\centerfigs{
  \prooftreeinline{
  \hypo{\dbl{T} \vDash X\ \ob}
  \hypo{\vdash \Gamma\ \context}
  \infer2{\Gamma \vdash \Ob_{\Disc(X)} = \Ob_X\ \type}
  }
  #{\qquad\qquad}
  \prooftreeinline{
  \hypo{\dbl{T} \vDash X\ \ob}
  \hypo{\Gamma \vdash x: \Ob_X}
  \infer2{\Gamma \vdash \varepsilon_X(x) = x: \Ob_X}
  }
  }}
  \prooftree{
  \hypo{\dbl{T} \vDash (F: X \to Y)}
  \hypo{\Gamma \vdash x: \Ob_X}
  \infer2{\Gamma \vdash (\Disc F)(x) = F(x) : \Ob_Y}
  }
  }

  \li{Computation rules for Hom types:

  \prooftree{
  \hypo{\dbl{T} \vDash X\ \ob}
  \hypo{\Gamma \vdash x: \Ob_X}
  \infer2{\Gamma \vdash \Hom_{\Disc(X)}(x,x) = 1\ \type}
  }
  \prooftree{
  \hypo{\dbl{T} \vDash X\ \ob}
  \hypo{\Gamma \vdash x, x': \Ob_X}
  \hypo{\Gamma \vdash f: \Hom_{\Disc(X)}(x, x')}
  \infer3{\Gamma \vdash x = x': \Ob_X}
  }
  \prooftree{
  \hypo{\dbl{T} \vDash X\ \ob}
  \hypo{\Gamma \vdash x, x': \Ob_X}
  \hypo{\Gamma \vdash f: \Hom_{\Disc(X)}(x, x')}
  \infer[dashed]3{\Gamma \vdash f = 1_x: \Hom_{\Disc(X)}(x, x)}
  }

  Note the close resemblance here to extensional equality types.
  }

  \li{Computation rule for morphism types:

  \prooftree{
  \hypo{\dbl{T} \vDash (P: X \proto Y)}
  \hypo{\Gamma \vdash x: \Ob_X}
  \hypo{\Gamma \vdash y: \Ob_Y}
  \infer3{\Gamma \vdash (\Disc P)(x,y) = 0\ \type}
  }
  \prooftree{
  \hypo{\dbl{T} \vDash (P: X \proto Y)}
  \hypo{\Gamma \vdash x: \Ob_X}
  \hypo{\Gamma \vdash y: \Ob_Y}
  \hypo{\Gamma \vdash p: (\Disc P)(x, y)}
  \infer4{\Gamma \vdash \varepsilon_P(p) = \ind_0(p): P(x,y)}
  }

  }

}
}
